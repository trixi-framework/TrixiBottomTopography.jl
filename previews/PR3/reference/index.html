<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · TrixiBottomTopography.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://maxbertrand1996.github.io/TrixiBottomTopography.jl/dev/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TrixiBottomTopography.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Overview</span><ul><li><a class="tocitem" href="../conversion/">Data Conversion</a></li><li><a class="tocitem" href="../structure/">B-spline structure</a></li><li><a class="tocitem" href="../function/">B-spline function</a></li></ul></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><a class="tocitem" href="../licence/">Licence</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/main/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TrixiBottomTopography.jl-API"><a class="docs-heading-anchor" href="#TrixiBottomTopography.jl-API">TrixiBottomTopography.jl API</a><a id="TrixiBottomTopography.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#TrixiBottomTopography.jl-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.TrixiBottomTopography" href="#TrixiBottomTopography.TrixiBottomTopography"><code>TrixiBottomTopography.TrixiBottomTopography</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">TrixiBottomTopography</code></pre><p><strong>TrixiBottomTopography</strong> is a supporting framework for Trixi.jl, which can be used to approximate bottom topography functions using B-splines from  real life data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/TrixiBottomTopography.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.BicubicBSpline" href="#TrixiBottomTopography.BicubicBSpline"><code>TrixiBottomTopography.BicubicBSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><p>BicubicBSpline(x, y, h, Q, IP)</p><p>Two dimensional cubic B-spline structure which contains all important attributes to define a B-Spline interpolation function.  These attributes are:</p><ul><li><code>x</code>: Vector of values in x-direction</li><li><code>y</code>: Vector of values in y-direction</li><li><code>h</code>: Length of one side of a single patch in the given data set. A patch is the area between two       consecutive <code>x</code> and <code>y</code> values. <code>h</code> corresponds to the distance between two consecutive       values in x-direction. As we are only considering Cartesian grids, <code>h</code> is equal for all       patches in x and y-direction </li><li><code>Q</code>: Matrix which contains the control points  </li><li><code>IP</code>: Coefficients matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_cache_2D.jl#L155-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.BicubicBSpline-Tuple{String}" href="#TrixiBottomTopography.BicubicBSpline-Tuple{String}"><code>TrixiBottomTopography.BicubicBSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BicubicBSpline(path::String; end_condition = &quot;free&quot;, smoothing_factor = 0.0)</code></pre><p>A function which reads in the <code>x</code>, <code>y</code> and <code>z</code> values for  <a href="@ref"><code>bicubic_b_spline(x::Vector, y::Vector, z::Matrix; end_condition = &quot;free&quot;, smoothing_factor = 0.0)</code></a>  from a .txt file. The input values are:</p><ul><li><code>path</code>: String of a path of the specific .txt file</li><li><code>end_condition</code>: a string which can either be <code>free</code> or <code>not-a-knot</code> and defines which                   end condition should be considered.                  By default this is set to <code>free</code></li><li><code>smoothing_factor</code>: a Float64 <span>$\geq$</span> 0.0 which specifies the degree of smoothing of the <code>y</code> values.                     By default this value is set to 0.0 which corresponds to no smoothing.</li></ul><p>The .txt file has to have the following structure to be interpreted by this function:</p><ul><li>First line: comment <code># Number of x values</code></li><li>Second line: integer which gives the number of <code>x</code> values</li><li>Third line: comment <code># Number of y values</code></li><li>Fourth line: integer which gives the number of <code>y</code> values</li><li>Fifth line: comment <code># x values</code></li><li>Following lines: the <code>x</code> values where each value has its own line</li><li>Line after the x-values: comment <code># y values</code></li><li>Following lines: <code>y</code> values where each value has its own line</li><li>Line after the y-values: comment <code># z values</code></li><li>Remaining lines: values for <code>z</code> where each value has its own line and is in th following order:                  z<em>11, z</em>12, ... z<em>1n, z</em>21, ... z<em>2n, ..., z</em>m1, ..., z_mn</li></ul><p>An example can be found <a href="https://gist.githubusercontent.com/maxbertrand1996/7b1b943eac142d5bc836bb818fe83a5a/raw/74228e349e91fbfe1563479f99943b469f26ac62/Rhine_data_2D_10.txt">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_cache_2D.jl#L533-L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.BicubicBSpline-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}" href="#TrixiBottomTopography.BicubicBSpline-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>TrixiBottomTopography.BicubicBSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BicubicBSpline(x::Vector, y::Vector, z::Matrix; end_condition = &quot;free&quot;, smoothing_factor = 0.0)</code></pre><p>This function calculates the inputs for the structure <a href="#TrixiBottomTopography.BicubicBSpline"><code>BicubicBSpline</code></a>. The input values are:</p><ul><li><code>x</code>: A vector which contains equally spaced values in x-direction</li><li><code>y</code>: A vector which contains equally spaced values in y-direction where the spacing between the      y-values has to be the same as the spacing between the x-values</li><li><code>z</code>: A matrix which contains the corresponding values in z-direction.      Where the values are ordered in the following way:</li></ul><p class="math-container">\[\begin{aligned}
  \begin{matrix}
    &amp; &amp; x_1 &amp; x_2 &amp; ... &amp; x_n\\
    &amp; &amp; &amp; &amp; &amp;\\
    y_1 &amp; &amp; z_{11} &amp; z_{12} &amp; ... &amp; z_{1n}\\
    y_1 &amp; &amp; z_{21} &amp; z_{22} &amp; ... &amp; z_{2n}\\
    \vdots &amp; &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
    y_m &amp; &amp; z_{m1} &amp; z_{m2} &amp; ... &amp; z_{mn}
  \end{matrix}
\end{aligned}\]</p><ul><li><code>end_condition</code>: a string which can either be <code>free</code> or <code>not-a-knot</code> and defines which                   end condition should be considered. By default this is set to <code>free</code>.</li><li><code>smoothing_factor</code>: a Float64 <span>$\geq$</span> 0.0 which specifies the degree of smoothing of the <code>z</code> values.                     By default this value is set to 0.0 which corresponds to no smoothing.</li></ul><p>Bicubic B-spline interpolation is only possible if the dimensions of vectors <code>x</code> and <code>y</code> correspond  with the dimensions of the matrix <code>z</code>.</p><p>First of all the data is sorted which is done by  <a href="#TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>sort_data</code></a> to guarantee  that the <code>x</code> and <code>y</code> values are in ascending order with corresponding matrix <code>z</code>.</p><p>The patch size <code>h</code> is calculated by subtracting the second by the first <code>x</code> value. This can be done  because we only consider equal space between consecutive <code>x</code> and <code>y</code> values.  (A patch is the area between two consecutive <code>x</code> and <code>y</code> values)</p><p>If a <code>smoothing_factor</code> <span>$&gt;$</span> 0.0 is set, the function <a href="#TrixiBottomTopography.calc_tps-Tuple{Number, Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>calc_tps</code></a>  calculates new values for <code>z</code> which guarantee a resulting parametric B-spline surface  with less curvature.</p><p>The coefficients matrix <code>IP</code> for bicubic B-splines is fixed to be</p><p class="math-container">\[\begin{aligned}
  \begin{pmatrix}
    -1 &amp; 3 &amp; -3 &amp; 1\\
    3 &amp; -6 &amp; 3 &amp; 0\\
    -3 &amp; 0 &amp; 3 &amp; 0\\
    1 &amp; 4 &amp; 1 &amp; 0
  \end{pmatrix}
\end{aligned}\]</p><p>To get the matrix of control points <code>Q</code> which is necessary to set up an interpolation function, we need to define a matrix <code>Phi</code> which maps the control points to a vector <code>P</code>. This can be done by solving the following linear equations system for <code>Q</code>.</p><p class="math-container">\[\underbrace{
  \begin{bmatrix}
    z_{1,1} \\ z_{1,2} \\ \vdots \\ z_{1,n} \\ z_{2,1} \\ \vdots \\ z_{m,n} \\ 0 \\ \vdots \\ 0
  \end{bmatrix}
  }_{\text{:=P} \in \mathbb{R}^{(m+2)(n+2)\times 1}} = \frac{1}{36}
  \Phi \cdot 
  \underbrace{\begin{bmatrix}
    Q_{1,1} \\ Q_{1,2} \\ \vdots \\ Q_{1,n+2} \\ Q_{2,1} \\ \vdots \\ Q_{m+2,n+2}
  \end{bmatrix}}_{\text{:= Q} \in \mathbb{R}^{(m+2) \times (n+2)}}\]</p><p>For the first <code>n</code> <span>$\cdot$</span> <code>m</code> lines, the matrix <code>Phi</code> is the same for the <code>free</code> end and the <code>not-a-knot</code> end condition. These lines have to address the following condition:</p><p class="math-container">\[\begin{align*}
			z_{j,i} = \frac{1}{36} \Big( &amp;Q_{j,i} + 4Q_{j+1,i} + Q_{j+2,i} + 4Q_{j,i+1} + 16Q_{j+1,i+1}\\ 
			&amp;+ 4Q_{j+2,i+1} + Q_{j,i+2} + 4Q_{j+1,i+2} + Q_{j+2,i+2} \Big) 
		\end{align*}\]</p><p>for i = 1,...,n and j = 1,...,m.</p><p>The <code>free</code> end condition needs at least two values for the <code>x</code> and <code>y</code> vectors. The free end condition has the following additional requirements for the control points which have  to be addressed by <code>Phi</code>:</p><ul><li><span>$Q_{j,1} - 2Q_{j,2} + Q_{j,3} = 0$</span> for j = 2,...,m+1</li><li><span>$Q_{j,n} - 2Q_{j,n+1} + Q_{j,n+2} = 0$</span> for j = 2,...,m+1</li><li><span>$Q_{1,i} - 2Q_{2,i} + Q_{3,i} = 0$</span> for i = 2,...,n+1</li><li><span>$Q_{m,i} - 2Q_{m+1,i} + Q_{m+2,i} = 0$</span> for i = 2,...,n+1</li><li><span>$Q_{1,1} - 2Q_{2,2} + Q_{3,3} = 0$</span></li><li><span>$Q_{m+2,1} - 2Q_{m+1,2} + Q_{m,3} = 0$</span></li><li><span>$Q_{1,n+2} - 2Q_{2,n+1} + Q_{3,n} = 0$</span></li><li><span>$Q_{m,n} - 2Q_{m+1,n+1} + Q_{m+2,n+2} = 0$</span></li></ul><p>The <code>not-a-knot</code> end condition needs at least four values for the <code>x</code> and <code>y</code> vectors.</p><ul><li>Continuity of the third <code>x</code> derivative between the leftmost and second leftmost patch</li><li>Continuity of the third <code>x</code> derivative between the rightmost and second rightmost patch</li><li>Continuity of the third <code>y</code> derivative between the patch at the top and the patch below</li><li>Continuity of the third <code>y</code> derivative between the patch at the bottom and the patch above</li><li><span>$Q_{1,1} - Q_{1,2} - Q_{2,1} + Q_{2,2} = 0$</span></li><li><span>$Q_{m-1,1} + Q_{m,1} + Q_{m-1,2} - Q_{m,2} = 0$</span></li><li><span>$Q_{1,n-1} + Q_{2,n} + Q_{1,n-1} - Q_{2,n} = 0$</span></li><li><span>$Q_{m-1,n-1} - Q_{m,n-1} - Q_{m-1,n} + Q_{m,n} = 0$</span></li></ul><p>A reference for the calculations in this script can be found in Chapter 2 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_cache_2D.jl#L179-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.BilinearBSpline" href="#TrixiBottomTopography.BilinearBSpline"><code>TrixiBottomTopography.BilinearBSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BilinearBSpline(x, y, h, Q, IP)</code></pre><p>Two dimensional bilinear B-spline structure which contains all important attributes to define a B-Spline interpolation function.  These attributes are:</p><ul><li><code>x</code>: Vector of values in x-direction</li><li><code>y</code>: Vector of values in y-direction</li><li><code>h</code>: Length of one side of a single patch in the given data set. A patch is the area between two       consecutive <code>x</code> and <code>y</code> values. <code>h</code> corresponds to the distance between two consecutive       values in x-direction. As we are only considering Cartesian grids, <code>h</code> is equal for all       patches in x and y-direction</li><li><code>Q</code>: Matrix which contains the control points</li><li><code>IP</code>: Coefficients matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_cache_2D.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.BilinearBSpline-Tuple{String}" href="#TrixiBottomTopography.BilinearBSpline-Tuple{String}"><code>TrixiBottomTopography.BilinearBSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BilinearBSpline(path::String)</code></pre><p>A function which reads in the <code>x</code>, <code>y</code> and <code>z</code> values for  <a href="#TrixiBottomTopography.BilinearBSpline"><code>BilinearBSpline</code></a> from a .txt  file. The input values are:</p><ul><li><code>path</code>: String of a path of the specific .txt file</li></ul><p>The .txt file has to have the following structure to be interpreted by this function:</p><ul><li>First line: comment <code># Number of x values</code></li><li>Second line: integer which gives the number of <code>x</code> values</li><li>Third line: comment <code># Number of y values</code></li><li>Fourth line: integer which gives the number of <code>y</code> values</li><li>Fifth line: comment <code># x values</code></li><li>Following lines: the <code>x</code> values where each value has its own line</li><li>Line after the x-values: comment <code># y values</code></li><li>Following lines: <code>y</code> values where each value has its own line</li><li>Line after the y-values: comment <code># z values</code></li><li>Remaining lines: values for <code>z</code> where each value has its own line and is in the following order:                  z<em>11, z</em>12, ... z<em>1n, z</em>21, ... z<em>2n, ..., z</em>m1, ..., z_mn</li></ul><p>An example can be found <a href="https://gist.githubusercontent.com/maxbertrand1996/7b1b943eac142d5bc836bb818fe83a5a/raw/74228e349e91fbfe1563479f99943b469f26ac62/Rhine_data_2D_10.txt">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_cache_2D.jl#L110-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.BilinearBSpline-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}" href="#TrixiBottomTopography.BilinearBSpline-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>TrixiBottomTopography.BilinearBSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BilinearBSpline(x::Vector, y::Vector, z::Matrix)</code></pre><p>This function calculates the inputs for the structure <a href="#TrixiBottomTopography.BilinearBSpline"><code>BilinearBSpline</code></a>. The input values are:</p><ul><li><code>x</code>: A vector which contains equally spaced values in x-direction</li><li><code>y</code>: A vector which contains equally spaced values in y-direction where the spacing between the      y-values has to be the same as the spacing between the x-values</li><li><code>z</code>: A matrix which contains the corresponding values in z-direction.      Where the values are ordered in the following way:</li></ul><p class="math-container">\[\begin{aligned}
  \begin{matrix}
    &amp; &amp; x_1 &amp; x_2 &amp; ... &amp; x_n\\
    &amp; &amp; &amp; &amp; &amp;\\
    y_1 &amp; &amp; z_{11} &amp; z_{12} &amp; ... &amp; z_{1n}\\
    y_1 &amp; &amp; z_{21} &amp; z_{22} &amp; ... &amp; z_{2n}\\
    \vdots &amp; &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
    y_m &amp; &amp; z_{m1} &amp; z_{m2} &amp; ... &amp; z_{mn}
  \end{matrix}
\end{aligned}\]</p><p>Bilinear B-spline interpolation is only possible if we have at least two values in <code>x</code>  and two values in <code>y</code> and the dimensions of vectors <code>x</code> and <code>y</code> correspond with the dimensions of the matrix <code>z</code>.</p><p>First of all the data is sorted which is done by  <a href="#TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>sort_data</code></a> to guarantee  that the <code>x</code> and <code>y</code> values are in ascending order with corresponding matrix <code>z</code>.</p><p>The patch size <code>h</code> is calculated by subtracting the second by the first <code>x</code> value. This can be done  because we only consider equal space between consecutive <code>x</code> and <code>y</code> values.  (A patch is the area between two consecutive <code>x</code> and <code>y</code> values)</p><p>For bilinear B-spline interpolation, the control points <code>Q</code> correspond with the <code>z</code> values.</p><p>The coefficients matrix <code>IP</code> for bilinear B-splines is fixed to be</p><p class="math-container">\[\begin{aligned}
  \begin{pmatrix}
    -1 &amp; 1\\
    1 &amp; 0
  \end{pmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 2 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_cache_2D.jl#L31-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.CubicBSpline" href="#TrixiBottomTopography.CubicBSpline"><code>TrixiBottomTopography.CubicBSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CubicBSpline(x, h, Q, IP)</code></pre><p>One dimensional cubic B-spline structure which contains all important attributes to define a B-Spline interpolation function. Similar to <a href="#TrixiBottomTopography.LinearBSpline"><code>LinearBSpline</code></a>  These attributes are:</p><ul><li><code>x</code>: Vector of values in x-direction</li><li><code>h</code>: Length of a single patch in the given data set. A patch is the area between two consecutive       <code>x</code> values. <code>h</code> corresponds to the distance between two consecutive values in x-direction.       As we are only considering Cartesian grids, <code>h</code> is equal for all patches</li><li><code>Q</code>: Vector which contains the Control points</li><li><code>IP</code>: Coefficients matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_cache_1D.jl#L122-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.CubicBSpline-Tuple{String}" href="#TrixiBottomTopography.CubicBSpline-Tuple{String}"><code>TrixiBottomTopography.CubicBSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CubicBSpline(path::String; end_condition = &quot;free&quot;, smoothing_factor = 0.0)</code></pre><p>A function which reads in the <code>x</code> and <code>y</code> values for <a href="#TrixiBottomTopography.CubicBSpline"><code>CubicBSpline</code></a> from a .txt file. The input values are:</p><ul><li><code>path</code>: String of a path of the specific .txt file</li><li><code>end_condition</code>: a string which can either be <code>free</code> or <code>not-a-knot</code> and defines which                   end condition should be considered.                  By default this is set to <code>free</code></li><li><code>smoothing_factor</code>: a Float64 &gt;= 0.0 which specifies the degree of smoothing of the <code>y</code> values.                     By default this value is set to <code>0.0</code> which corresponds to no smoothing.</li></ul><p>The .txt file has to have the following structure to be interpreted by this function:</p><ul><li>First line: comment <code># Number of x values</code></li><li>Second line: integer which gives the number of <code>x</code> values</li><li>Third line: comment <code># x values</code></li><li>Following lines: the <code>x</code> values where each value has its own line</li><li>Line after the x-values: comment <code># y values</code></li><li>Remaining lines: <code>y</code> values where each value has its own line  </li></ul><p>Note that the number of <code>x</code> and <code>y</code> values have to be the same. An example can be found <a href="https://gist.githubusercontent.com/maxbertrand1996/b05a90e66025ee1ebddf444a32c3fa01/raw/90d375c1ac11b26589aab1fe92bd0e6f6daf37b7/Rhine_data_1D_10.txt">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_cache_1D.jl#L304-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.CubicBSpline-Tuple{Vector{T} where T, Vector{T} where T}" href="#TrixiBottomTopography.CubicBSpline-Tuple{Vector{T} where T, Vector{T} where T}"><code>TrixiBottomTopography.CubicBSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CubicBSpline(x::Vector, y::Vector; end_condition = &quot;free&quot;, smoothing_factor = 0.0)</code></pre><p>This function calculates the inputs for the structure <a href="#TrixiBottomTopography.CubicBSpline"><code>CubicBSpline</code></a>. The input values are:</p><ul><li><code>x</code>: a Vector which contains equally spaces values in x-direction</li><li><code>y</code>: a Vector which contains values in y-direction</li><li><code>end_condition</code>: a string which can either be <code>free</code> or <code>not-a-knot</code> and defines which                   end condition should be considered. By default this is set to <code>free</code>.</li><li><code>smoothing_factor</code>: a Float64 <span>$\geq$</span> 0.0 which specifies the degree of smoothing of the <code>y</code>                      values. By default this value is set to <code>0.0</code> which corresponds to no                      smoothing.</li></ul><p>First of all the data is sorted which is done by <a href="#TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>sort_data</code></a> to guarantee that the <code>x</code> values are in ascending order.</p><p>The patch size <code>h</code> is calculated by subtracting the second and first <code>x</code> value. This can be done because we only consider equally spaced <code>x</code> values.  (A patch is the area between two consecutive <code>x</code> values)</p><p>If a <code>smoothing_factor</code>  &gt; 0.0 is set, the function <a href="#TrixiBottomTopography.spline_smoothing-Tuple{Number, Number, Vector{T} where T}"><code>spline_smoothing</code></a> calculates new <code>y</code> values which guarantee a B-Spline with less curvature.</p><p>The coefficients matrix <code>IP</code> for linear B-splines is fixed to be</p><p class="math-container">\[\begin{aligned}
  IP = \begin{pmatrix}
    -1 &amp; 3 &amp; -3 &amp; 1\\
    3 &amp; -6 &amp; 3 &amp; 0\\
    -3 &amp; 0 &amp; 3 &amp; 0\\
    1 &amp; 4 &amp; 1 &amp; 0
  \end{pmatrix}
\end{aligned}\]</p><p>The <code>free</code> end condition requires the second and the second last control points is exactly between the first and the third control point and the second last control points is  between the third last and the last control point. It is only possible with at least two values in <code>x</code>. The linear equations system to determine the control points has the following form:</p><p class="math-container">\[\begin{aligned}
		\underbrace{\begin{bmatrix}
				0 \\ P_1 \\ P_2 \\ \vdots \\ P_{n-1} \\ P_n\\ 0 
		\end{bmatrix}}_{:= P^*_{\text{free}}}
		= \frac{1}{6}
		\underbrace{
			\begin{bmatrix}
				1 &amp; -2 &amp; 1 &amp; 0 &amp; ... &amp; ... &amp; 0 \\
				1      &amp; 4 &amp; 1 &amp; 0 &amp; ... &amp; ... &amp; 0\\
				0      &amp; 1 &amp; 4 &amp; 1 &amp; 0   &amp;     &amp;     \vdots\\
				\vdots &amp;  0      &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0 &amp; \vdots\\
				\vdots &amp;       &amp; 0 &amp; 1 &amp; 4 &amp; 1 &amp; 0\\
				0 &amp; ... &amp; ... &amp; 0 &amp; 1 &amp; 4 &amp; 1\\
				0 &amp; ... &amp; ... &amp; 0 &amp; 1 &amp; -2 &amp; 1
			\end{bmatrix}
		}_{:= \Phi^*_{\text{free}}}
		\underbrace{\begin{bmatrix}
				Q_1 \\ Q_2 \\ Q_3 \\ \vdots \\ Q_n \\ Q_{n+1} \\ Q_{n+2}
		\end{bmatrix}}_{:= Q_{\text{free}}},
	\end{aligned}\]</p><p>which is solved for <span>$Q_{\text{free}}$</span>.</p><p>The <code>not-a-knot</code> end condition requires the continuity of the third derivative in the second and second last fit knot. This end condition is only possible with at least four values in <code>x</code>. The linear equations system to determine the control points has the following form:</p><p class="math-container">\[\begin{aligned}
		\underbrace{\begin{bmatrix}
				0 \\ P_1 \\ P_2 \\ \vdots \\ P_{n-1} \\ P_n\\ 0 
		\end{bmatrix}}_{:= P^*_{\text{not-a-knot}}}
		= \frac{1}{6}
		\underbrace{
			\begin{bmatrix}
				-1 &amp; 4 &amp; -6 &amp; 4 &amp; -1 &amp; 0 &amp;... &amp;  0 \\
				1      &amp; 4 &amp; 1 &amp; 0 &amp; ... &amp; ... &amp; ... &amp; 0\\
				0      &amp; 1 &amp; 4 &amp; 1 &amp; 0   &amp;     &amp;     &amp;\vdots\\
				\vdots &amp;  0      &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0 &amp; &amp;\vdots\\
				\vdots &amp;  &amp; 0      &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0 &amp;\vdots\\
				\vdots &amp;    &amp;   &amp; 0 &amp; 1 &amp; 4 &amp; 1 &amp; 0\\
				0 &amp; ... &amp; ...  &amp; ... &amp; 0 &amp; 1 &amp; 4 &amp; 1\\
				0 &amp; ... &amp; 0 &amp; -1 &amp; 4 &amp; -6 &amp; 4 &amp; -1
			\end{bmatrix}
		}_{:= \Phi^*_{\text{not-a-knot}}}
		\underbrace{\begin{bmatrix}
				Q_1 \\ Q_2 \\ Q_3 \\ \vdots \\ \vdots \\ Q_n \\ Q_{n+1} \\ Q_{n+2}
		\end{bmatrix}}_{:= Q_{\text{not-a-knot}}}.
	\end{aligned}\]</p><p>which is solved for <span>$Q_{\text{not-a-knot}}$</span>.</p><p>For both cases <span>$P_1,...,P_n = y_1,...,y_n$</span>.</p><p>A reference for the calculations in this script can be found in Chapter 1 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_cache_1D.jl#L143-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.LinearBSpline" href="#TrixiBottomTopography.LinearBSpline"><code>TrixiBottomTopography.LinearBSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearBSpline(x, h, Q, IP)</code></pre><p>One dimensional linear B-spline structure which contains all important attributes to define a B-Spline interpolation function.  These attributes are:</p><ul><li><code>x</code>: Vector of values in x-direction</li><li><code>h</code>: Length of a single patch in the given data set. A patch is the area between two consecutive       <code>x</code> values. <code>h</code> corresponds to the distance between two consecutive values in x-direction.       As we are only considering Cartesian grids, <code>h</code> is equal for all patches</li><li><code>Q</code>: Vector which contains the control points</li><li><code>IP</code>: Coefficients matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_cache_1D.jl#L7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.LinearBSpline-Tuple{String}" href="#TrixiBottomTopography.LinearBSpline-Tuple{String}"><code>TrixiBottomTopography.LinearBSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearBSpline(path::String)</code></pre><p>A function which reads in the <code>x</code> and <code>y</code> values for  <a href="#TrixiBottomTopography.LinearBSpline"><code>LinearBSpline</code></a> from a .txt file. The input values are:</p><ul><li><code>path</code>: String of a path of the specific .txt file</li></ul><p>The .txt file has to have the following structure to be interpreted by this function:</p><ul><li>First line: comment <code># Number of x values</code></li><li>Second line: integer which gives the number of <code>x</code> values</li><li>Third line: comment <code># x values</code></li><li>Following lines: the <code>x</code> values where each value has its own line</li><li>Line after the x-values: comment <code># y values</code></li><li>Remaining lines: <code>y</code> values where each value has its own line  </li></ul><p>Note that the number of <code>x</code> and <code>y</code> values have to be the same. An example can be found <a href="https://gist.githubusercontent.com/maxbertrand1996/b05a90e66025ee1ebddf444a32c3fa01/raw/90d375c1ac11b26589aab1fe92bd0e6f6daf37b7/Rhine_data_1D_10.txt">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_cache_1D.jl#L85-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.LinearBSpline-Tuple{Vector{T} where T, Vector{T} where T}" href="#TrixiBottomTopography.LinearBSpline-Tuple{Vector{T} where T, Vector{T} where T}"><code>TrixiBottomTopography.LinearBSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearBSpline(x::Vector, y::Vector)</code></pre><p>This function calculates the inputs for the structure <a href="#TrixiBottomTopography.LinearBSpline"><code>LinearBSpline</code></a>. The input values are:</p><ul><li><code>x</code>: A vector which contains equally spaced values in x-direction</li><li><code>y</code>: A vector which contains values in y-direction</li></ul><p>Linear B-spline interpolation is only possible if we have at least two values in <code>x</code>. </p><p>First of all the data is sorted which is done by <a href="#TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>sort_data</code></a> to  guarantee that the <code>x</code> values are in ascending order.</p><p>The patch size <code>h</code> is calculated by subtracting the second and first <code>x</code> value. This can be done because we only consider equally spaced <code>x</code> values.  (A patch is the area between two consecutive <code>x</code> values)</p><p>For linear B-spline interpolation, the control points <code>Q</code> correspond with the values in <code>y</code>.</p><p>The coefficients matrix <code>IP</code> for linear B-splines is fixed to be</p><p class="math-container">\[\begin{aligned}
  \begin{pmatrix}
    -1 &amp; 1\\
    1 &amp; 0
  \end{pmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 1 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),   Cubic and bicubic spline interpolation in Python.   <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_cache_1D.jl#L28-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.calc_tps-Tuple{Number, Vector{T} where T, Vector{T} where T, Matrix{T} where T}" href="#TrixiBottomTopography.calc_tps-Tuple{Number, Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>TrixiBottomTopography.calc_tps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_tps(lambda::Number, x::Vector, y::Vector, z::Matrix)</code></pre><p>The inputs to this function are:</p><ul><li><code>lambda</code>: a smoothing factor which specifies the degree of the smoothing that should take place</li><li><code>x</code>: a vector of <code>x</code> values </li><li><code>y</code>: a vector of <code>x</code> values</li><li><code>z</code>: a matrix with the <code>z</code> values to be smoothed where the values of <code>z</code> correspond to the      indexing <code>(y,x)</code></li></ul><p>This function uses the thin plate spline approach to perform the smoothing. To do so the following linear equations system has to be solved for <code>coeff</code>:</p><p class="math-container">\[\begin{aligned}
		\underbrace{
		\begin{bmatrix}
			K &amp; P \\
			P^T &amp; O
		\end{bmatrix}
		}_{:= L}
		\underbrace{\begin{bmatrix}
			w \\ a
		\end{bmatrix}}_{\text{:= coeff}}
		=
		\underbrace{\begin{bmatrix}
			z\\o
		\end{bmatrix}}_{\text{:= rhs}}
\end{aligned}\]</p><p>First of all the inputs are restructured using the function <a href="#TrixiBottomTopography.restructure_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>restructure_data</code></a> and saved in the variables <code>x_hat</code>, <code>y_hat</code> and <code>z_hat</code>.</p><p>Then the matrix <code>L</code> can be filled by setting  <code>K</code> = <a href="#TrixiBottomTopography.tps_base_func-Tuple{Number}"><code>tps_base_func</code></a><code>(||(x_hat[i], y_hat[i]) - (x_hat[j], y_hat[j])||)</code> where <code>|| ||</code> is  the Eucledian norm, <code>P</code> = <code>[1 x y]</code> and <code>O</code> = <span>$3\times 3$</span> zeros matrix.</p><p>Afterwards the vector <code>rhs</code> is filled by setting <code>z</code> = <code>z_hat</code> and <code>o</code> = a vector with three zeros.</p><p>Now the system is solved to redeem the vector <code>coeff</code>. This vector is then used to calculate the smoothed values for <code>z</code> and save them in <code>H_f</code> by  the following function:</p><p class="math-container">\[\begin{align*}
H\_f[i] = &amp;a[1] + a[2]x\_hat[i] + a[3]y\_hat[i] \\
        + &amp;\sum_{j = 0}^p tps\_base\_func(\|(x\_hat[i], y\_hat[i]) - (x\_hat[j], y\_hat[j]) \|)
\end{align*}\]</p><p>here <code>p</code> is the number of entries in <code>z_hat</code>.</p><p>A reference to the calculations can be found in the lecture notes of</p><ul><li>Gianluca Donato and Serge Belongie (2001), Approximate Thin Plate Spline Mappings <a href="https://link.springer.com/content/pdf/10.1007/3-540-47977-5_2.pdf">DOI: 10.1007/3-540-47977-5_2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_utils_2D.jl#L103-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.convert_dgm_1d-Tuple{String, String}" href="#TrixiBottomTopography.convert_dgm_1d-Tuple{String, String}"><code>TrixiBottomTopography.convert_dgm_1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_dgm_1d(path_read::String, path_write::String, excerpt = 1, direction = &quot;x&quot;, section = 1)</code></pre><p>Function to convert <a href="https://www.opengeodata.nrw.de/produkte/geobasis/hm/dgm1_xyz/dgm1_xyz/">DGM</a> data files into one dimensional readable files.</p><p>Inputs:</p><ul><li><code>path_read</code>: String of the path of the DGM data which should be converted</li><li><code>path_write</code>: String of the path where the new file shuold be saved.              (Needs to also include the name of the file)</li><li><code>excerpt</code>: Optional integer that specifies which portion of the data should be written down. E.g.           if excerpt is set to 10, only every 10th <code>x</code> and <code>y</code> value are considered with their           corresponsing <code>z</code> values. The default value is 1 which means that every value is written           down.</li><li><code>direction</code>: Optional String which specifies if the one dimensional data should be read from the             <code>x</code> or <code>y</code> direction. By default this is set to the <code>x</code> direction</li><li><code>section</code>: Optional interger which can be between 1 and 1000 and soecifies which section of the          other dimension should be chosen. By default this values is set to 1 which means           that if direction is set to <code>x</code>, the corresponding <code>z</code> values are taken with respect to the          first <code>y</code> value. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/auxiliary/convert.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.convert_dgm_2d-Tuple{String, String}" href="#TrixiBottomTopography.convert_dgm_2d-Tuple{String, String}"><code>TrixiBottomTopography.convert_dgm_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_dgm_2d(path_read::String, path_write::String; excerpt = 1)</code></pre><p>Function to convert <a href="https://www.opengeodata.nrw.de/produkte/geobasis/hm/dgm1_xyz/dgm1_xyz/">DGM</a> data files into two dimensional readable files.</p><p>Inputs:</p><ul><li><code>path_read</code>: String of the path of the DGM data which should be converted</li><li><code>path_write</code>: String of the path where the new file shuold be saved.              (Needs to also include the name of the file)</li><li><code>excerpt</code>: Optional integer that specifies which portion of the data should be written down. E.g.           if excerpt is set to 10, only every 10th <code>x</code> and <code>y</code> value are considered with their           corresponsing <code>z</code> values. The default value is 1 which means that every value is written           down.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/auxiliary/convert.jl#L119-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.restructure_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}" href="#TrixiBottomTopography.restructure_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>TrixiBottomTopography.restructure_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">  restructure_data(x::Vector, y::Vector, z::Matrix)</code></pre><p>This function restructures the input values</p><ul><li><code>x</code>: a vector with <code>n</code> values in x-direction</li><li><code>y</code>: a vector with <code>m</code> values in y-direction</li><li><code>z</code>: a  <code>m</code> <span>$\times$</span> <code>n</code> matrix with values in z-direction where the values of <code>z</code> correspond       to the indexing <code>(y,x)</code></li></ul><p>The output is of the following form:</p><p class="math-container">\[\begin{aligned}
  \begin{bmatrix}
    x_1 &amp; y_1 &amp; z_{1,1}\\
    x_2 &amp; y_1 &amp; z_{1,2}\\
    &amp; \vdots &amp; \\
    x_n &amp; y_1 &amp; z_{1,n}\\
    x_1 &amp; y_2 &amp; z_{2,1}\\
    &amp; \vdots &amp; \\
    x_n &amp; y_m &amp; z_{m,n}
  \end{bmatrix}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_utils_2D.jl#L63-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}" href="#TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}"><code>TrixiBottomTopography.sort_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_data(x::Vector, y::Vector, z::Matrix)</code></pre><p>This function sorts the inputs vectors <code>x</code> and <code>y</code> in a ascending order and also reorders the input matrix <code>z</code> accordingly. </p><p>Therefore first the <code>x</code> values are sorted with the matrix <code>z</code> accordingly and afterwards the <code>y</code> values are sorted with the matrix <code>z</code> accordingly.</p><p>The sorted <code>x</code>, <code>y</code> and <code>z</code> values are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_utils_2D.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T}" href="#TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T}"><code>TrixiBottomTopography.sort_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_data(x::Vector,y::Vector)</code></pre><p>Sorts the input vectors <code>x</code> and <code>y</code> so that <code>x</code> is in ascending order and the <code>y</code> values still correspond to the <code>x</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_utils_1D.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.spline_interpolation-Tuple{BicubicBSpline, Any, Any}" href="#TrixiBottomTopography.spline_interpolation-Tuple{BicubicBSpline, Any, Any}"><code>TrixiBottomTopography.spline_interpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spline_interpolation(b_spline::BicubicBSpline, u, v)</code></pre><p>The inputs are the <a href="#TrixiBottomTopography.BicubicBSpline"><code>BicubicBSpline</code></a> object and the variable <code>u</code> and <code>v</code> at which the spline  will be evaluated. Where <code>u</code> corresponds to a value in x-direction and <code>v</code> to a value in  y-direction.</p><p>The parameters <code>i</code> and <code>j</code> give us the patch in which <code>(u,v)</code> is located. Which will also be used to get the correct control points from <code>Q</code>. (A patch is the area between two consecutive <code>x</code> and <code>y</code> values)</p><p><code>my</code> is  an interim variable which maps <code>u</code> to the interval <span>$[0,1]$</span> for further calculations. <code>ny</code> does the same for <code>v</code>.</p><p>To evaluate the spline at <code>(u,v)</code>, we have to calculate the following:</p><p class="math-container">\[\begin{aligned}
c_{i,j,3}(\mu_i,\nu_j) = \frac{1}{36}
\begin{bmatrix} \nu_j^3 \\ \nu_j^2 \\ \nu_j \\ 1 \end{bmatrix}^T
\underbrace{\begin{bmatrix}
  -1 &amp; 3 &amp; -3 &amp; 1\\
  3 &amp; -6 &amp; 3 &amp; 0\\
  -3 &amp; 0 &amp; 3 &amp; 0\\
  1 &amp; 4 &amp; 1 &amp; 0
\end{bmatrix}}_{\text{IP}}
\begin{bmatrix}
  Q_{i,j} &amp; Q_{i+1,j} &amp; Q_{i+2,j} &amp; Q_{i+3,j}\\
  Q_{i,j+1} &amp; Q_{i+1,j+1} &amp; Q_{i+2,j+1} &amp; Q_{i+3,j+1}\\
  Q_{i,j+2} &amp; Q_{i+1,j+2} &amp; Q_{i+2,j+2} &amp; Q_{i+3,j+2}\\
  Q_{i,j+3} &amp; Q_{i+1,j+3} &amp; Q_{i+2,j+3} &amp; Q_{i+3,j+3}
\end{bmatrix}
\underbrace{\begin{bmatrix}
  -1 &amp; 3 &amp; -3 &amp; 1\\
  3 &amp; -6 &amp; 0 &amp; 4\\
  -3 &amp; 3 &amp; 3 &amp; 1\\
  1 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}}_{\text{IP}}
\begin{bmatrix} \mu_i^3 \\ \mu_i^2 \\ \mu_i \\ 1 \end{bmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 2 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_methods_2D.jl#L60-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.spline_interpolation-Tuple{BilinearBSpline, Any, Any}" href="#TrixiBottomTopography.spline_interpolation-Tuple{BilinearBSpline, Any, Any}"><code>TrixiBottomTopography.spline_interpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spline_interpolation(b_spline::BilinearBSpline, u, v)</code></pre><p>The inputs are the <a href="#TrixiBottomTopography.BilinearBSpline"><code>BilinearBSpline</code></a> object and the variable <code>u</code> and <code>v</code> at which the spline  will be evaluated. Where <code>u</code> corresponds to a value in x-direction and <code>v</code> to a value in  y-direction.</p><p>The parameters <code>i</code> and <code>j</code> give us the patch in which <code>(u,v)</code> is located. Which will also be used to get the correct control points from <code>Q</code>. (A patch is the area between two consecutive <code>x</code> and <code>y</code> values)</p><p><code>my</code> is  an interim variable which maps <code>u</code> to the interval <span>$[0,1]$</span> for further calculations. <code>ny</code> does the same for <code>v</code>.</p><p>To evaluate the spline at <code>(u,v)</code>, we have to calculate the following:</p><p class="math-container">\[\begin{aligned}
c_{i,j,1}(\mu_i(u),\nu_j(v)) = 
		\begin{bmatrix} \mu_i(u)\\ 1 \end{bmatrix}^T
		\underbrace{\begin{bmatrix} -1 &amp; 1\\ 1 &amp; 0 \end{bmatrix}}_{\text{IP}}
		\begin{bmatrix} Q_{i,j} &amp; Q_{i,j+1}\\ Q_{i+1,j} &amp; Q_{i+1,j+1} \end{bmatrix}
		\underbrace{\begin{bmatrix} -1 &amp; 1\\ 1 &amp; 0 \end{bmatrix}}_{\text{IP}^T}
		\begin{bmatrix} \nu_j(v) \\ 1\end{bmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 2 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020)  Cubic and bicubic spline interpolation in Python.   <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_methods_2D.jl#L7-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.spline_interpolation-Tuple{CubicBSpline, Any}" href="#TrixiBottomTopography.spline_interpolation-Tuple{CubicBSpline, Any}"><code>TrixiBottomTopography.spline_interpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spline_interpolation(b_spline::CubicBSpline, t)</code></pre><p>The inputs are the <a href="#TrixiBottomTopography.CubicBSpline"><code>CubicBSpline</code></a> object and a variable <code>t</code> at which the spline  will be evaluated.</p><p>The parameter <code>i</code> gives us the patch in which the variable <code>t</code> is located. This parameter will also be used to get the correct control points from <code>Q</code>. (A patch is the area between two consecutive <code>x</code> values)</p><p><code>kappa</code> is  an interim variable which maps <code>t</code> to the interval <span>$[0,1]$</span> for further calculations.</p><p>To evaluate the spline at <code>t</code>, we have to calculate the following:</p><p class="math-container">\[\begin{aligned}
c_{i,3}\left(\kappa_i(t) \right) = \frac{1}{6} 
		\begin{bmatrix}
			\kappa_i(t)^3\\ \kappa_i(t)^2\\ \kappa_i(t) \\1
		\end{bmatrix}^T
		\underbrace{\begin{bmatrix}
			-1 &amp; 3 &amp; -3 &amp; 1\\
			3 &amp; -6 &amp; 3 &amp; 0\\
			-3 &amp; 0 &amp; 3 &amp; 0\\
			1 &amp; 4 &amp; 1 &amp; 0
		\end{bmatrix}}_{\text{IP}}
		\begin{bmatrix}
			Q_{i,\text{free}}\\ Q_{i+1,\text{free}}\\ Q_{i+2,\text{free}}\\ Q_{i+3,\text{free}}
		\end{bmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 1 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_methods_1D.jl#L58-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.spline_interpolation-Tuple{LinearBSpline, Any}" href="#TrixiBottomTopography.spline_interpolation-Tuple{LinearBSpline, Any}"><code>TrixiBottomTopography.spline_interpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spline_interpolation(b_spline::LinearBSpline, t)</code></pre><p>The inputs are the <a href="#TrixiBottomTopography.LinearBSpline"><code>LinearBSpline</code></a> object and a variable <code>t</code> at which the spline  will be evaluated.</p><p>The parameter <code>i</code> gives us the patch in which the variable <code>t</code> is located. This parameter will also be used to get the correct control points from <code>Q</code>. (A patch is the area between two consecutive <code>x</code> values. <code>h</code>)</p><p><code>kappa</code> is  an interim variable which maps <code>t</code> to the interval <span>$[0,1]$</span> for further calculations.</p><p>To evaluate the spline at <code>t</code>, we have to calculate the following:</p><p class="math-container">\[\begin{aligned}
c_{i,1}(\kappa_i) = 
		\begin{bmatrix}
			\kappa_i\\ 1
		\end{bmatrix}^T
		\begin{bmatrix}
			-1 &amp; 1\\1 &amp; 0
		\end{bmatrix}
		\begin{bmatrix}
			Q_i\\Q_{i+1}
		\end{bmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 1 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_methods_1D.jl#L7-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.spline_smoothing-Tuple{Number, Number, Vector{T} where T}" href="#TrixiBottomTopography.spline_smoothing-Tuple{Number, Number, Vector{T} where T}"><code>TrixiBottomTopography.spline_smoothing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spline_smoothing(lambda::Number, h::Number, y::Vector)</code></pre><p>The inputs to this function are:</p><ul><li><code>lambda</code>: a smoothing factor which specifies the degree of the smoothing that should take place</li><li><code>h</code>: the step size of a patch (A patch is the area between two consecutive <code>x</code> values)</li><li><code>y</code>: the <code>y</code> values to be smoothed</li></ul><p>The goal is to find a new interpolation values <span>$\hat{y}$</span> for <span>$y$</span>, so that for given <span>$\lambda$</span>,  the following equation is minimized:</p><p class="math-container">\[\begin{aligned}
		\text{PSS} = \sum_{i = 1}^{n} \left( y_i - \underbrace{S(t_i)}_{=\hat{y}_i} \right)^2 
    + \lambda \int_{x_1}^{x_n} (S&#39;&#39;(t))^2 dt,
	\end{aligned}\]</p><p>where <span>$S(t)$</span> is a cubic spline function.  <span>$\hat{y}$</span> is determined as follows:</p><p class="math-container">\[\begin{aligned}
\hat{y} = (I+\lambda K)^{-1} y
\end{aligned}\]</p><p>where <span>$I$</span> is the <span>$n \times n$</span> identity matrix and <span>$K = \Delta^T W^{-1} \Delta$</span> with</p><p class="math-container">\[\begin{aligned}
\Delta = \begin{pmatrix}
1/h &amp; -2/h &amp; 1/h &amp; ... &amp; 0\\
0 &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0\\
0 &amp; ... &amp; 1/h &amp; -2/h &amp; 1/h
\end{pmatrix} \in \mathbb{R}^{(n-2) \times n}
\end{aligned}\]</p><p>and</p><p class="math-container">\[\begin{aligned}
W = \begin{pmatrix}
2/3 h &amp; 1/6 h &amp; 0 &amp; ... &amp; 0\\
1/6 h &amp; 2/3 h &amp; 1/6 h &amp; ... &amp; 0\\
0 &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0\\
0 &amp; ... &amp; 0 &amp; 2/3 h &amp; 1/6 h
\end{pmatrix} \in \mathbb{R}^{n \times n}
\end{aligned}\]</p><ul><li>Germán Rodríguez (2001),</li></ul><p><a href="https://data.princeton.edu/eco572/smoothing.pdf">Smoothing and non-parametric regression</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/1D/spline_utils_1D.jl#L25-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrixiBottomTopography.tps_base_func-Tuple{Number}" href="#TrixiBottomTopography.tps_base_func-Tuple{Number}"><code>TrixiBottomTopography.tps_base_func</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tps_base_func(r::Number)</code></pre><p>Thin plate spline basis function.</p><ul><li>Gianluca Donato and Serge Belongie (2001) Approximate Thin Plate Spline Mappings <a href="https://link.springer.com/content/pdf/10.1007/3-540-47977-5_2.pdf">DOI: 10.1007/3-540-47977-5_2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxbertrand1996/TrixiBottomTopography.jl/blob/6d95bc5f20120eb5ed153762e256d7c90415c6f7/src/2D/spline_utils_2D.jl#L43-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../function/">« B-spline function</a><a class="docs-footer-nextpage" href="../licence/">Licence »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 8 November 2022 09:06">Tuesday 8 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
