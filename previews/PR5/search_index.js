var documenterSearchIndex = {"docs":
[{"location":"conversion/#Converting-DGM-data-files","page":"Data Conversion","title":"Converting DGM data files","text":"","category":"section"},{"location":"conversion/#Introduction","page":"Data Conversion","title":"Introduction","text":"","category":"section"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"Often geographical data is provided in form of .xzy files. These files organized geographical data in three columns seperated by [space] with an x, y and z component. For example:","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"1.0 1.0 1.0\n2.0 1.0 2.0\n3.0 1.0 3.0\n1.0 2.0 4.0\n2.0 2.0 5.0\n3.0 2.0 6.0\n1.0 3.0 7.0\n2.0 3.0 8.0\n3.0 3.0 9.0","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"In the example above, we have 1.0, 2.0, 3.0 as possible x and y coordinate values. .xyz files provide the corresponding z value for all possible x-y combinations. In this case this means that for example at [2.0, 3.0], the corresponding z value is 6.0. ","category":"page"},{"location":"conversion/#DGM-data-set","page":"Data Conversion","title":"DGM data set","text":"","category":"section"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"In the examples folder of this repo, the underlying data has been received from  Geobasis NRW. They provide a geographical data set of the whole German state of Nort Rhine-Westphalia called DGM. This data set contains patches of 1km^2 where each patch has the elevation data for 1.000.000 data points equally distributed as a grid with grid size of 1m. The data is given as .xyz files:","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"357000.00 5646999.00 47.40 \n357001.00 5646999.00 47.43 \n357002.00 5646999.00 47.49 \n357003.00 5646999.00 47.47 \n357004.00 5646999.00 47.39 \n357005.00 5646999.00 47.30 \n357006.00 5646999.00 47.24 \n...       ...        ...","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"where the first column provides the corresponding ETRS89 East coordinates, the second column the ETRS89 North coordinates and the third column the DHHN2016 height.","category":"page"},{"location":"conversion/#Data-format-of-TrixiBottomTopography.jl","page":"Data Conversion","title":"Data format of TrixiBottomTopography.jl","text":"","category":"section"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"The provided .xyz files of DGM are not directly accepted by TrixiBottomTopography.jl to define B-spline interpolation structures. ","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"This package requires .txt files in a specific data format. To interpolate one dimensional data, TrixiBottomTopography.jl requires the following form:","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"# Number of x values\nn\n# x values\nx_1\n...\nx_n\n# y values\ny_1\n...\ny_n","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"To interpolate two dimensional data:","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"# Number of x values\nn\n# Number of y values\nm\n# x values\nx_1\n...\nx_n\n# y values\ny_1\n...\ny_m\n# z values\nz_1,1\nz_1,2\n...\nz_1,n\nz_2,1\n...\nz_m,n","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"The x, y and z values have to be given in Float64 format.","category":"page"},{"location":"conversion/#Conversion-functions","page":"Data Conversion","title":"Conversion functions","text":"","category":"section"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"To make matters easier TrixiBottomTopography.jl provides the functions convert_dgm_1d for one dimensional interpolation and convert_dgm_2d for two dimensional interpolation.","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"To explain these functions, we are taking a look at the example file convert_data.jl.","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"First we import our package to be able to use the functions.","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"# Include packages\nusing TrixiBottomTopography","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"Then we define the path of the .xyz file path_src_file that we want to convert, as well as the paths of the files where we want to save the files.","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"# Get root directory\ndir_path = pkgdir(TrixiBottomTopography)\n\n# Define file paths\npath_src_file = string(dir_path, \"/examples/data/dgm1_32_357_5646_1_nw.xyz\")\npath_out_file_1d_x = string(dir_path, \"/examples/data/rhine_data_1d_20_x.txt\")\npath_out_file_1d_y = string(dir_path, \"/examples/data/rhine_data_1d_20_y.txt\")\npath_out_file_2d = string(dir_path, \"/examples/data/rhine_data_2d_20.txt\")","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"The source data from path_src_file looks as follows:","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"357000.00 5646999.00 47.40 \n357001.00 5646999.00 47.43 \n357002.00 5646999.00 47.49 \n357003.00 5646999.00 47.47 \n357004.00 5646999.00 47.39 \n357005.00 5646999.00 47.30 \n357006.00 5646999.00 47.24 \n...       ...        ...","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"Here you can see the full file.","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"Now the data can be converted.","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"# Convert data\nconvert_dgm_1d(path_src_file, path_out_file_1d_x; excerpt = 20, section = 100)","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"Calling this expression tells convert_dgm_1d that the source file is path_src_file and the converted file will be saved in the file path_out_file_1d_x. The optional attribute excerpt tells the function that only every 20th point in x direction (in this case in the ETRS89 East coordinate) will be considered. Setting section to 100 tells the function that the corresponding z values (DHHN2016 in this case) from the 100th y coordinate (ETRS89 North) will be chosen. (Click here to view the resulting file)","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"convert_dgm_1d(path_src_file, path_out_file_1d_y; excerpt = 20, direction = \"y\", section = 100)","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"Similar to the previous expression, this one has the additional attribute directon = \"y\" which tells convert_dgm_1d that the data will be read from the y direction. (Click here to view the resulting file)","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"onvert_dgm_2d(path_src_file, path_out_file_2d; excerpt = 20)","category":"page"},{"location":"conversion/","page":"Data Conversion","title":"Data Conversion","text":"The two dimensional version convert_dgm_2d works similar to the one dimensional case except that the optional attributes direction and section do not exist, but only excerpt. Setting excerpt = 20 tells the function that only every 20th value in the x and y direction of the source file path_src_file will be stored in path_out_file_2d. (Click here to view the resulting file)","category":"page"},{"location":"licence/#License","page":"Licence","title":"License","text":"","category":"section"},{"location":"licence/","page":"Licence","title":"Licence","text":"MIT LicenseCopyright (c) 2022 Maximilian Dominique BertrandPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"reference/#TrixiBottomTopography.jl-API","page":"Reference","title":"TrixiBottomTopography.jl API","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = TrixiBottomTopography","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [TrixiBottomTopography]","category":"page"},{"location":"reference/#TrixiBottomTopography.TrixiBottomTopography","page":"Reference","title":"TrixiBottomTopography.TrixiBottomTopography","text":"TrixiBottomTopography\n\nTrixiBottomTopography is a supporting framework for Trixi.jl, which can be used to approximate bottom topography functions using B-splines from  real life data.\n\n\n\n\n\n","category":"module"},{"location":"reference/#TrixiBottomTopography.BicubicBSpline","page":"Reference","title":"TrixiBottomTopography.BicubicBSpline","text":"BicubicBSpline(x, y, h, Q, IP)\n\nTwo dimensional cubic B-spline structure which contains all important attributes to define a B-Spline interpolation function.  These attributes are:\n\nx: Vector of values in x-direction\ny: Vector of values in y-direction\nh: Length of one side of a single patch in the given data set. A patch is the area between two       consecutive x and y values. h corresponds to the distance between two consecutive       values in x-direction. As we are only considering Cartesian grids, h is equal for all       patches in x and y-direction \nQ: Matrix which contains the control points  \nIP: Coefficients matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#TrixiBottomTopography.BicubicBSpline-Tuple{String}","page":"Reference","title":"TrixiBottomTopography.BicubicBSpline","text":"BicubicBSpline(path::String; end_condition = \"free\", smoothing_factor = 0.0)\n\nA function which reads in the x, y and z values for  bicubic_b_spline(x::Vector, y::Vector, z::Matrix; end_condition = \"free\", smoothing_factor = 0.0)  from a .txt file. The input values are:\n\npath: String of a path of the specific .txt file\nend_condition: a string which can either be free or not-a-knot and defines which                   end condition should be considered.                  By default this is set to free\nsmoothing_factor: a Float64 geq 0.0 which specifies the degree of smoothing of the y values.                     By default this value is set to 0.0 which corresponds to no smoothing.\n\nThe .txt file has to have the following structure to be interpreted by this function:\n\nFirst line: comment # Number of x values\nSecond line: integer which gives the number of x values\nThird line: comment # Number of y values\nFourth line: integer which gives the number of y values\nFifth line: comment # x values\nFollowing lines: the x values where each value has its own line\nLine after the x-values: comment # y values\nFollowing lines: y values where each value has its own line\nLine after the y-values: comment # z values\nRemaining lines: values for z where each value has its own line and is in th following order:                  z11, z12, ... z1n, z21, ... z2n, ..., zm1, ..., z_mn\n\nAn example can be found here\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.BicubicBSpline-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}","page":"Reference","title":"TrixiBottomTopography.BicubicBSpline","text":"BicubicBSpline(x::Vector, y::Vector, z::Matrix; end_condition = \"free\", smoothing_factor = 0.0)\n\nThis function calculates the inputs for the structure BicubicBSpline. The input values are:\n\nx: A vector which contains equally spaced values in x-direction\ny: A vector which contains equally spaced values in y-direction where the spacing between the      y-values has to be the same as the spacing between the x-values\nz: A matrix which contains the corresponding values in z-direction.      Where the values are ordered in the following way:\n\nbeginaligned\n  beginmatrix\n      x_1  x_2    x_n\n        \n    y_1   z_11  z_12    z_1n\n    y_1   z_21  z_22    z_2n\n    vdots   vdots  vdots  ddots  vdots\n    y_m   z_m1  z_m2    z_mn\n  endmatrix\nendaligned\n\nend_condition: a string which can either be free or not-a-knot and defines which                   end condition should be considered. By default this is set to free.\nsmoothing_factor: a Float64 geq 0.0 which specifies the degree of smoothing of the z values.                     By default this value is set to 0.0 which corresponds to no smoothing.\n\nBicubic B-spline interpolation is only possible if the dimensions of vectors x and y correspond  with the dimensions of the matrix z.\n\nFirst of all the data is sorted which is done by  sort_data to guarantee  that the x and y values are in ascending order with corresponding matrix z.\n\nThe patch size h is calculated by subtracting the second by the first x value. This can be done  because we only consider equal space between consecutive x and y values.  (A patch is the area between two consecutive x and y values)\n\nIf a smoothing_factor  0.0 is set, the function calc_tps  calculates new values for z which guarantee a resulting parametric B-spline surface  with less curvature.\n\nThe coefficients matrix IP for bicubic B-splines is fixed to be\n\nbeginaligned\n  beginpmatrix\n    -1  3  -3  1\n    3  -6  3  0\n    -3  0  3  0\n    1  4  1  0\n  endpmatrix\nendaligned\n\nTo get the matrix of control points Q which is necessary to set up an interpolation function, we need to define a matrix Phi which maps the control points to a vector P. This can be done by solving the following linear equations system for Q.\n\nunderbrace\n  beginbmatrix\n    z_11  z_12  vdots  z_1n  z_21  vdots  z_mn  0  vdots  0\n  endbmatrix\n  _text=P in mathbbR^(m+2)(n+2)times 1 = frac136\n  Phi cdot \n  underbracebeginbmatrix\n    Q_11  Q_12  vdots  Q_1n+2  Q_21  vdots  Q_m+2n+2\n  endbmatrix_text= Q in mathbbR^(m+2) times (n+2)\n\nFor the first n cdot m lines, the matrix Phi is the same for the free end and the not-a-knot end condition. These lines have to address the following condition:\n\nbeginalign*\n\t\t\tz_ji = frac136 Big( Q_ji + 4Q_j+1i + Q_j+2i + 4Q_ji+1 + 16Q_j+1i+1 \n\t\t\t+ 4Q_j+2i+1 + Q_ji+2 + 4Q_j+1i+2 + Q_j+2i+2 Big) \n\t\tendalign*\n\nfor i = 1,...,n and j = 1,...,m.\n\nThe free end condition needs at least two values for the x and y vectors. The free end condition has the following additional requirements for the control points which have  to be addressed by Phi:\n\nQ_j1 - 2Q_j2 + Q_j3 = 0 for j = 2,...,m+1\nQ_jn - 2Q_jn+1 + Q_jn+2 = 0 for j = 2,...,m+1\nQ_1i - 2Q_2i + Q_3i = 0 for i = 2,...,n+1\nQ_mi - 2Q_m+1i + Q_m+2i = 0 for i = 2,...,n+1\nQ_11 - 2Q_22 + Q_33 = 0\nQ_m+21 - 2Q_m+12 + Q_m3 = 0\nQ_1n+2 - 2Q_2n+1 + Q_3n = 0\nQ_mn - 2Q_m+1n+1 + Q_m+2n+2 = 0\n\nThe not-a-knot end condition needs at least four values for the x and y vectors.\n\nContinuity of the third x derivative between the leftmost and second leftmost patch\nContinuity of the third x derivative between the rightmost and second rightmost patch\nContinuity of the third y derivative between the patch at the top and the patch below\nContinuity of the third y derivative between the patch at the bottom and the patch above\nQ_11 - Q_12 - Q_21 + Q_22 = 0\nQ_m-11 + Q_m1 + Q_m-12 - Q_m2 = 0\nQ_1n-1 + Q_2n + Q_1n-1 - Q_2n = 0\nQ_m-1n-1 - Q_mn-1 - Q_m-1n + Q_mn = 0\n\nA reference for the calculations in this script can be found in Chapter 2 of\n\nQuentin Agrapart & Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.BilinearBSpline","page":"Reference","title":"TrixiBottomTopography.BilinearBSpline","text":"BilinearBSpline(x, y, h, Q, IP)\n\nTwo dimensional bilinear B-spline structure which contains all important attributes to define a B-Spline interpolation function.  These attributes are:\n\nx: Vector of values in x-direction\ny: Vector of values in y-direction\nh: Length of one side of a single patch in the given data set. A patch is the area between two       consecutive x and y values. h corresponds to the distance between two consecutive       values in x-direction. As we are only considering Cartesian grids, h is equal for all       patches in x and y-direction\nQ: Matrix which contains the control points\nIP: Coefficients matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#TrixiBottomTopography.BilinearBSpline-Tuple{String}","page":"Reference","title":"TrixiBottomTopography.BilinearBSpline","text":"BilinearBSpline(path::String)\n\nA function which reads in the x, y and z values for  BilinearBSpline from a .txt  file. The input values are:\n\npath: String of a path of the specific .txt file\n\nThe .txt file has to have the following structure to be interpreted by this function:\n\nFirst line: comment # Number of x values\nSecond line: integer which gives the number of x values\nThird line: comment # Number of y values\nFourth line: integer which gives the number of y values\nFifth line: comment # x values\nFollowing lines: the x values where each value has its own line\nLine after the x-values: comment # y values\nFollowing lines: y values where each value has its own line\nLine after the y-values: comment # z values\nRemaining lines: values for z where each value has its own line and is in the following order:                  z11, z12, ... z1n, z21, ... z2n, ..., zm1, ..., z_mn\n\nAn example can be found here\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.BilinearBSpline-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}","page":"Reference","title":"TrixiBottomTopography.BilinearBSpline","text":"BilinearBSpline(x::Vector, y::Vector, z::Matrix)\n\nThis function calculates the inputs for the structure BilinearBSpline. The input values are:\n\nx: A vector which contains equally spaced values in x-direction\ny: A vector which contains equally spaced values in y-direction where the spacing between the      y-values has to be the same as the spacing between the x-values\nz: A matrix which contains the corresponding values in z-direction.      Where the values are ordered in the following way:\n\nbeginaligned\n  beginmatrix\n      x_1  x_2    x_n\n        \n    y_1   z_11  z_12    z_1n\n    y_1   z_21  z_22    z_2n\n    vdots   vdots  vdots  ddots  vdots\n    y_m   z_m1  z_m2    z_mn\n  endmatrix\nendaligned\n\nBilinear B-spline interpolation is only possible if we have at least two values in x  and two values in y and the dimensions of vectors x and y correspond with the dimensions of the matrix z.\n\nFirst of all the data is sorted which is done by  sort_data to guarantee  that the x and y values are in ascending order with corresponding matrix z.\n\nThe patch size h is calculated by subtracting the second by the first x value. This can be done  because we only consider equal space between consecutive x and y values.  (A patch is the area between two consecutive x and y values)\n\nFor bilinear B-spline interpolation, the control points Q correspond with the z values.\n\nThe coefficients matrix IP for bilinear B-splines is fixed to be\n\nbeginaligned\n  beginpmatrix\n    -1  1\n    1  0\n  endpmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 2 of\n\nQuentin Agrapart & Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.CubicBSpline","page":"Reference","title":"TrixiBottomTopography.CubicBSpline","text":"CubicBSpline(x, h, Q, IP)\n\nOne dimensional cubic B-spline structure which contains all important attributes to define a B-Spline interpolation function. Similar to LinearBSpline  These attributes are:\n\nx: Vector of values in x-direction\nh: Length of a single patch in the given data set. A patch is the area between two consecutive       x values. h corresponds to the distance between two consecutive values in x-direction.       As we are only considering Cartesian grids, h is equal for all patches\nQ: Vector which contains the Control points\nIP: Coefficients matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#TrixiBottomTopography.CubicBSpline-Tuple{String}","page":"Reference","title":"TrixiBottomTopography.CubicBSpline","text":"CubicBSpline(path::String; end_condition = \"free\", smoothing_factor = 0.0)\n\nA function which reads in the x and y values for CubicBSpline from a .txt file. The input values are:\n\npath: String of a path of the specific .txt file\nend_condition: a string which can either be free or not-a-knot and defines which                   end condition should be considered.                  By default this is set to free\nsmoothing_factor: a Float64 >= 0.0 which specifies the degree of smoothing of the y values.                     By default this value is set to 0.0 which corresponds to no smoothing.\n\nThe .txt file has to have the following structure to be interpreted by this function:\n\nFirst line: comment # Number of x values\nSecond line: integer which gives the number of x values\nThird line: comment # x values\nFollowing lines: the x values where each value has its own line\nLine after the x-values: comment # y values\nRemaining lines: y values where each value has its own line  \n\nNote that the number of x and y values have to be the same. An example can be found here\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.CubicBSpline-Tuple{Vector{T} where T, Vector{T} where T}","page":"Reference","title":"TrixiBottomTopography.CubicBSpline","text":"CubicBSpline(x::Vector, y::Vector; end_condition = \"free\", smoothing_factor = 0.0)\n\nThis function calculates the inputs for the structure CubicBSpline. The input values are:\n\nx: a Vector which contains equally spaces values in x-direction\ny: a Vector which contains values in y-direction\nend_condition: a string which can either be free or not-a-knot and defines which                   end condition should be considered. By default this is set to free.\nsmoothing_factor: a Float64 geq 0.0 which specifies the degree of smoothing of the y                      values. By default this value is set to 0.0 which corresponds to no                      smoothing.\n\nFirst of all the data is sorted which is done by sort_data to guarantee that the x values are in ascending order.\n\nThe patch size h is calculated by subtracting the second and first x value. This can be done because we only consider equally spaced x values.  (A patch is the area between two consecutive x values)\n\nIf a smoothing_factor  > 0.0 is set, the function spline_smoothing calculates new y values which guarantee a B-Spline with less curvature.\n\nThe coefficients matrix IP for linear B-splines is fixed to be\n\nbeginaligned\n  IP = beginpmatrix\n    -1  3  -3  1\n    3  -6  3  0\n    -3  0  3  0\n    1  4  1  0\n  endpmatrix\nendaligned\n\nThe free end condition requires the second and the second last control points is exactly between the first and the third control point and the second last control points is  between the third last and the last control point. It is only possible with at least two values in x. The linear equations system to determine the control points has the following form:\n\nbeginaligned\n\t\tunderbracebeginbmatrix\n\t\t\t\t0  P_1  P_2  vdots  P_n-1  P_n 0 \n\t\tendbmatrix_= P^*_textfree\n\t\t= frac16\n\t\tunderbrace\n\t\t\tbeginbmatrix\n\t\t\t\t1  -2  1  0      0 \n\t\t\t\t1       4  1  0      0\n\t\t\t\t0       1  4  1  0             vdots\n\t\t\t\tvdots   0       ddots  ddots  ddots  0  vdots\n\t\t\t\tvdots         0  1  4  1  0\n\t\t\t\t0      0  1  4  1\n\t\t\t\t0      0  1  -2  1\n\t\t\tendbmatrix\n\t\t_= Phi^*_textfree\n\t\tunderbracebeginbmatrix\n\t\t\t\tQ_1  Q_2  Q_3  vdots  Q_n  Q_n+1  Q_n+2\n\t\tendbmatrix_= Q_textfree\n\tendaligned\n\nwhich is solved for Q_textfree.\n\nThe not-a-knot end condition requires the continuity of the third derivative in the second and second last fit knot. This end condition is only possible with at least four values in x. The linear equations system to determine the control points has the following form:\n\nbeginaligned\n\t\tunderbracebeginbmatrix\n\t\t\t\t0  P_1  P_2  vdots  P_n-1  P_n 0 \n\t\tendbmatrix_= P^*_textnot-a-knot\n\t\t= frac16\n\t\tunderbrace\n\t\t\tbeginbmatrix\n\t\t\t\t-1  4  -6  4  -1  0    0 \n\t\t\t\t1       4  1  0        0\n\t\t\t\t0       1  4  1  0             vdots\n\t\t\t\tvdots   0       ddots  ddots  ddots  0  vdots\n\t\t\t\tvdots    0       ddots  ddots  ddots  0 vdots\n\t\t\t\tvdots         0  1  4  1  0\n\t\t\t\t0         0  1  4  1\n\t\t\t\t0    0  -1  4  -6  4  -1\n\t\t\tendbmatrix\n\t\t_= Phi^*_textnot-a-knot\n\t\tunderbracebeginbmatrix\n\t\t\t\tQ_1  Q_2  Q_3  vdots  vdots  Q_n  Q_n+1  Q_n+2\n\t\tendbmatrix_= Q_textnot-a-knot\n\tendaligned\n\nwhich is solved for Q_textnot-a-knot.\n\nFor both cases P_1P_n = y_1y_n.\n\nA reference for the calculations in this script can be found in Chapter 1 of\n\nQuentin Agrapart & Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.LinearBSpline","page":"Reference","title":"TrixiBottomTopography.LinearBSpline","text":"LinearBSpline(x, h, Q, IP)\n\nOne dimensional linear B-spline structure which contains all important attributes to define a B-Spline interpolation function.  These attributes are:\n\nx: Vector of values in x-direction\nh: Length of a single patch in the given data set. A patch is the area between two consecutive       x values. h corresponds to the distance between two consecutive values in x-direction.       As we are only considering Cartesian grids, h is equal for all patches\nQ: Vector which contains the control points\nIP: Coefficients matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#TrixiBottomTopography.LinearBSpline-Tuple{String}","page":"Reference","title":"TrixiBottomTopography.LinearBSpline","text":"LinearBSpline(path::String)\n\nA function which reads in the x and y values for  LinearBSpline from a .txt file. The input values are:\n\npath: String of a path of the specific .txt file\n\nThe .txt file has to have the following structure to be interpreted by this function:\n\nFirst line: comment # Number of x values\nSecond line: integer which gives the number of x values\nThird line: comment # x values\nFollowing lines: the x values where each value has its own line\nLine after the x-values: comment # y values\nRemaining lines: y values where each value has its own line  \n\nNote that the number of x and y values have to be the same. An example can be found here\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.LinearBSpline-Tuple{Vector{T} where T, Vector{T} where T}","page":"Reference","title":"TrixiBottomTopography.LinearBSpline","text":"LinearBSpline(x::Vector, y::Vector)\n\nThis function calculates the inputs for the structure LinearBSpline. The input values are:\n\nx: A vector which contains equally spaced values in x-direction\ny: A vector which contains values in y-direction\n\nLinear B-spline interpolation is only possible if we have at least two values in x. \n\nFirst of all the data is sorted which is done by sort_data to  guarantee that the x values are in ascending order.\n\nThe patch size h is calculated by subtracting the second and first x value. This can be done because we only consider equally spaced x values.  (A patch is the area between two consecutive x values)\n\nFor linear B-spline interpolation, the control points Q correspond with the values in y.\n\nThe coefficients matrix IP for linear B-splines is fixed to be\n\nbeginaligned\n  beginpmatrix\n    -1  1\n    1  0\n  endpmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 1 of\n\nQuentin Agrapart & Alain Batailly (2020),   Cubic and bicubic spline interpolation in Python.   hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.calc_tps-Tuple{Number, Vector{T} where T, Vector{T} where T, Matrix{T} where T}","page":"Reference","title":"TrixiBottomTopography.calc_tps","text":"calc_tps(lambda::Number, x::Vector, y::Vector, z::Matrix)\n\nThe inputs to this function are:\n\nlambda: a smoothing factor which specifies the degree of the smoothing that should take place\nx: a vector of x values \ny: a vector of x values\nz: a matrix with the z values to be smoothed where the values of z correspond to the      indexing (y,x)\n\nThis function uses the thin plate spline approach to perform the smoothing. To do so the following linear equations system has to be solved for coeff:\n\nbeginaligned\n\t\tunderbrace\n\t\tbeginbmatrix\n\t\t\tK  P \n\t\t\tP^T  O\n\t\tendbmatrix\n\t\t_= L\n\t\tunderbracebeginbmatrix\n\t\t\tw  a\n\t\tendbmatrix_text= coeff\n\t\t=\n\t\tunderbracebeginbmatrix\n\t\t\tzo\n\t\tendbmatrix_text= rhs\nendaligned\n\nFirst of all the inputs are restructured using the function restructure_data and saved in the variables x_hat, y_hat and z_hat.\n\nThen the matrix L can be filled by setting  K = tps_base_func(||(x_hat[i], y_hat[i]) - (x_hat[j], y_hat[j])||) where || || is  the Eucledian norm, P = [1 x y] and O = 3times 3 zeros matrix.\n\nAfterwards the vector rhs is filled by setting z = z_hat and o = a vector with three zeros.\n\nNow the system is solved to redeem the vector coeff. This vector is then used to calculate the smoothed values for z and save them in H_f by  the following function:\n\nbeginalign*\nH_fi = a1 + a2x_hati + a3y_hati \n        + sum_j = 0^p tps_base_func((x_hati y_hati) - (x_hatj y_hatj) )\nendalign*\n\nhere p is the number of entries in z_hat.\n\nA reference to the calculations can be found in the lecture notes of\n\nGianluca Donato and Serge Belongie (2001), Approximate Thin Plate Spline Mappings DOI: 10.1007/3-540-47977-5_2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.convert_dgm_1d-Tuple{String, String}","page":"Reference","title":"TrixiBottomTopography.convert_dgm_1d","text":"convert_dgm_1d(path_read::String, path_write::String, excerpt = 1, direction = \"x\", section = 1)\n\nFunction to convert DGM data files into one dimensional readable files.\n\nInputs:\n\npath_read: String of the path of the DGM data which should be converted\npath_write: String of the path where the new file shuold be saved.              (Needs to also include the name of the file)\nexcerpt: Optional integer that specifies which portion of the data should be written down. E.g.           if excerpt is set to 10, only every 10th x and y value are considered with their           corresponsing z values. The default value is 1 which means that every value is written           down.\ndirection: Optional String which specifies if the one dimensional data should be read from the             x or y direction. By default this is set to the x direction\nsection: Optional interger which can be between 1 and 1000 and soecifies which section of the          other dimension should be chosen. By default this values is set to 1 which means           that if direction is set to x, the corresponding z values are taken with respect to the          first y value. \n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.convert_dgm_2d-Tuple{String, String}","page":"Reference","title":"TrixiBottomTopography.convert_dgm_2d","text":"convert_dgm_2d(path_read::String, path_write::String; excerpt = 1)\n\nFunction to convert DGM data files into two dimensional readable files.\n\nInputs:\n\npath_read: String of the path of the DGM data which should be converted\npath_write: String of the path where the new file shuold be saved.              (Needs to also include the name of the file)\nexcerpt: Optional integer that specifies which portion of the data should be written down. E.g.           if excerpt is set to 10, only every 10th x and y value are considered with their           corresponsing z values. The default value is 1 which means that every value is written           down.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.restructure_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}","page":"Reference","title":"TrixiBottomTopography.restructure_data","text":"  restructure_data(x::Vector, y::Vector, z::Matrix)\n\nThis function restructures the input values\n\nx: a vector with n values in x-direction\ny: a vector with m values in y-direction\nz: a  m times n matrix with values in z-direction where the values of z correspond       to the indexing (y,x)\n\nThe output is of the following form:\n\nbeginaligned\n  beginbmatrix\n    x_1  y_1  z_11\n    x_2  y_1  z_12\n     vdots  \n    x_n  y_1  z_1n\n    x_1  y_2  z_21\n     vdots  \n    x_n  y_m  z_mn\n  endbmatrix\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T, Matrix{T} where T}","page":"Reference","title":"TrixiBottomTopography.sort_data","text":"sort_data(x::Vector, y::Vector, z::Matrix)\n\nThis function sorts the inputs vectors x and y in a ascending order and also reorders the input matrix z accordingly. \n\nTherefore first the x values are sorted with the matrix z accordingly and afterwards the y values are sorted with the matrix z accordingly.\n\nThe sorted x, y and z values are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.sort_data-Tuple{Vector{T} where T, Vector{T} where T}","page":"Reference","title":"TrixiBottomTopography.sort_data","text":"sort_data(x::Vector,y::Vector)\n\nSorts the input vectors x and y so that x is in ascending order and the y values still correspond to the x values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_interpolation-Tuple{BicubicBSpline, Any, Any}","page":"Reference","title":"TrixiBottomTopography.spline_interpolation","text":"spline_interpolation(b_spline::BicubicBSpline, u, v)\n\nThe inputs are the BicubicBSpline object and the variable u and v at which the spline  will be evaluated. Where u corresponds to a value in x-direction and v to a value in  y-direction.\n\nThe parameters i and j give us the patch in which (u,v) is located. Which will also be used to get the correct control points from Q. (A patch is the area between two consecutive x and y values)\n\nmy is  an interim variable which maps u to the interval 01 for further calculations. ny does the same for v.\n\nTo evaluate the spline at (u,v), we have to calculate the following:\n\nbeginaligned\nc_ij3(mu_inu_j) = frac136\nbeginbmatrix nu_j^3  nu_j^2  nu_j  1 endbmatrix^T\nunderbracebeginbmatrix\n  -1  3  -3  1\n  3  -6  3  0\n  -3  0  3  0\n  1  4  1  0\nendbmatrix_textIP\nbeginbmatrix\n  Q_ij  Q_i+1j  Q_i+2j  Q_i+3j\n  Q_ij+1  Q_i+1j+1  Q_i+2j+1  Q_i+3j+1\n  Q_ij+2  Q_i+1j+2  Q_i+2j+2  Q_i+3j+2\n  Q_ij+3  Q_i+1j+3  Q_i+2j+3  Q_i+3j+3\nendbmatrix\nunderbracebeginbmatrix\n  -1  3  -3  1\n  3  -6  0  4\n  -3  3  3  1\n  1  0  0  0\nendbmatrix_textIP\nbeginbmatrix mu_i^3  mu_i^2  mu_i  1 endbmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 2 of\n\nQuentin Agrapart & Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_interpolation-Tuple{BilinearBSpline, Any, Any}","page":"Reference","title":"TrixiBottomTopography.spline_interpolation","text":"spline_interpolation(b_spline::BilinearBSpline, u, v)\n\nThe inputs are the BilinearBSpline object and the variable u and v at which the spline  will be evaluated. Where u corresponds to a value in x-direction and v to a value in  y-direction.\n\nThe parameters i and j give us the patch in which (u,v) is located. Which will also be used to get the correct control points from Q. (A patch is the area between two consecutive x and y values)\n\nmy is  an interim variable which maps u to the interval 01 for further calculations. ny does the same for v.\n\nTo evaluate the spline at (u,v), we have to calculate the following:\n\nbeginaligned\nc_ij1(mu_i(u)nu_j(v)) = \n\t\tbeginbmatrix mu_i(u) 1 endbmatrix^T\n\t\tunderbracebeginbmatrix -1  1 1  0 endbmatrix_textIP\n\t\tbeginbmatrix Q_ij  Q_ij+1 Q_i+1j  Q_i+1j+1 endbmatrix\n\t\tunderbracebeginbmatrix -1  1 1  0 endbmatrix_textIP^T\n\t\tbeginbmatrix nu_j(v)  1endbmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 2 of\n\nQuentin Agrapart & Alain Batailly (2020)  Cubic and bicubic spline interpolation in Python.   hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_interpolation-Tuple{CubicBSpline, Any}","page":"Reference","title":"TrixiBottomTopography.spline_interpolation","text":"spline_interpolation(b_spline::CubicBSpline, t)\n\nThe inputs are the CubicBSpline object and a variable t at which the spline  will be evaluated.\n\nThe parameter i gives us the patch in which the variable t is located. This parameter will also be used to get the correct control points from Q. (A patch is the area between two consecutive x values)\n\nkappa is  an interim variable which maps t to the interval 01 for further calculations.\n\nTo evaluate the spline at t, we have to calculate the following:\n\nbeginaligned\nc_i3left(kappa_i(t) right) = frac16 \n\t\tbeginbmatrix\n\t\t\tkappa_i(t)^3 kappa_i(t)^2 kappa_i(t) 1\n\t\tendbmatrix^T\n\t\tunderbracebeginbmatrix\n\t\t\t-1  3  -3  1\n\t\t\t3  -6  3  0\n\t\t\t-3  0  3  0\n\t\t\t1  4  1  0\n\t\tendbmatrix_textIP\n\t\tbeginbmatrix\n\t\t\tQ_itextfree Q_i+1textfree Q_i+2textfree Q_i+3textfree\n\t\tendbmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 1 of\n\nQuentin Agrapart & Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_interpolation-Tuple{LinearBSpline, Any}","page":"Reference","title":"TrixiBottomTopography.spline_interpolation","text":"spline_interpolation(b_spline::LinearBSpline, t)\n\nThe inputs are the LinearBSpline object and a variable t at which the spline  will be evaluated.\n\nThe parameter i gives us the patch in which the variable t is located. This parameter will also be used to get the correct control points from Q. (A patch is the area between two consecutive x values. h)\n\nkappa is  an interim variable which maps t to the interval 01 for further calculations.\n\nTo evaluate the spline at t, we have to calculate the following:\n\nbeginaligned\nc_i1(kappa_i) = \n\t\tbeginbmatrix\n\t\t\tkappa_i 1\n\t\tendbmatrix^T\n\t\tbeginbmatrix\n\t\t\t-1  11  0\n\t\tendbmatrix\n\t\tbeginbmatrix\n\t\t\tQ_iQ_i+1\n\t\tendbmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 1 of\n\nQuentin Agrapart & Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.   hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_smoothing-Tuple{Number, Number, Vector{T} where T}","page":"Reference","title":"TrixiBottomTopography.spline_smoothing","text":"spline_smoothing(lambda::Number, h::Number, y::Vector)\n\nThe inputs to this function are:\n\nlambda: a smoothing factor which specifies the degree of the smoothing that should take place\nh: the step size of a patch (A patch is the area between two consecutive x values)\ny: the y values to be smoothed\n\nThe goal is to find a new interpolation values haty for y, so that for given lambda,  the following equation is minimized:\n\nbeginaligned\n\t\ttextPSS = sum_i = 1^n left( y_i - underbraceS(t_i)_=haty_i right)^2 \n    + lambda int_x_1^x_n (S(t))^2 dt\n\tendaligned\n\nwhere S(t) is a cubic spline function.  haty is determined as follows:\n\nbeginaligned\nhaty = (I+lambda K)^-1 y\nendaligned\n\nwhere I is the n times n identity matrix and K = Delta^T W^-1 Delta with\n\nbeginaligned\nDelta = beginpmatrix\n1h  -2h  1h    0\n0  ddots  ddots  ddots  0\n0    1h  -2h  1h\nendpmatrix in mathbbR^(n-2) times n\nendaligned\n\nand\n\nbeginaligned\nW = beginpmatrix\n23 h  16 h  0    0\n16 h  23 h  16 h    0\n0  ddots  ddots  ddots  0\n0    0  23 h  16 h\nendpmatrix in mathbbR^n times n\nendaligned\n\nGermán Rodríguez (2001),\n\nSmoothing and non-parametric regression\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.tps_base_func-Tuple{Number}","page":"Reference","title":"TrixiBottomTopography.tps_base_func","text":"tps_base_func(r::Number)\n\nThin plate spline basis function.\n\nGianluca Donato and Serge Belongie (2001) Approximate Thin Plate Spline Mappings DOI: 10.1007/3-540-47977-5_2\n\n\n\n\n\n","category":"method"},{"location":"structure/#B-spline-interpolation-structure","page":"B-spline structure","title":"B-spline interpolation structure","text":"","category":"section"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"If you have the underlying data in the correct format, you can start defining B-spline structures which are later used to define the interpolation functions. ","category":"page"},{"location":"structure/#One-dimensional-structures","page":"B-spline structure","title":"One dimensional structures","text":"","category":"section"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"For the one dimensional case, the structures LinearBSpline and CubicBspline are implemented which contain all relevant values to define linear and cubic B-spline interpolation functions correspond to linear and cubic B-spline interpolation. These are:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"x: A vector of values in x-direction\nh: The length of a single patch in the given data set. A patch is the area between two consecutive       x values. h corresponds to the distance between two consecutive values in x-direction.       As we are only considering Cartesian grids, h is equal for all patches\nQ: A vector which contains the control points\nIP: The coefficients matrix","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"To populate the structure, the outer constructor functions LinearBSpline(data_path) and CubicBSpline(data_path) which use the files in data_path to obtain the values which will be stored in the corresponding structure, as well as LinearBSpline(x,y) and CubicBSpline(x,y) which use given vectors x and y.","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"To get a better idea of the constructor functions, we are taking a look at example rhine_data_cubic-nak.jl from the examples folder of this repo which reads one dimensional bottom topography data from a .txt file and does a cubic B-spline interpolation with not-a-knot end condition and smoothing of the data.","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"# Include packages\nusing TrixiBottomTopography\nusing Plots\n\n# Get root directory\ndir_path = pkgdir(TrixiBottomTopography)\n\n# Define data path\ndata = string(dir_path, \"/examples/data/rhine_data_1d_20_x.txt\")\n\n# Define B-spline structure\nspline_struct = CubicBSpline(data; end_condition = \"not-a-knot\", smoothing_factor = 999)","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"For the cubic case we can also set the optional parameters end_condition which defines (as the name suggests) the end condition of the spline. Implemented are the not-a-knot and the free end condition. By default, end_condition is set to free. If you are not familiar with the differences between these end conditions, see Chapter 1 of","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Quentin Agrapart & Alain Batailly (2020),","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Cubic and bicubic spline interpolation in Python.  hal-03017566v2","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Besides the end condition, in the cubic case, we can also specify a smoothing_factor, which defines trade-off degree of the cubic B-spline interpolation of goodness of fit and minimizing the curvature by defining new y values. This proceedure is called spline smooothing. There is no general approach which smoothing_factor is best suited for the problem and has to be determined via trial and error. To understand the underlying maths, please see:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Germán Rodríguez (2001), Smoothing and non-parametric regression","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"In the next chapter, we are going to continue with the presented example.","category":"page"},{"location":"structure/#Two-dimensional-structures","page":"B-spline structure","title":"Two dimensional structures","text":"","category":"section"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"For the one dimensional case, the structures BilinearBSpline and BicubicBSpline are implemented which contain all relevant values to define bilinear and bicubic B-spline interpolation functions correspond to linear and cubic B-spline interpolation. These are:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"x: Vector of values in x-direction\ny: Vector of values in y-direction\nh: Length of one side of a single patch in the given data set. A patch is the area between two       consecutive x and y values. h corresponds to the distance between two consecutive       values in x-direction. As we are only considering Cartesian grids, h is equal for all       patches in x and y-direction\nQ: Matrix which contains the control points\nIP: Coefficients matrix","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"To populate the structure, the outer constructor functions BilinearBSpline(data_path) and BicubicBSpline(data_path) which use the files in data_path to obtain the values which will be stored in the corresponding structure, as well as BilinearBSpline(x,y,z) and BicubicBSpline(x,y,z) which use given vectors x and y and the matrix z which has the following form:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"beginaligned\nbeginmatrix\n      x_1  x_2    x_n\n        \n    y_1   z_11  z_12    z_1n\n    y_1   z_21  z_22    z_2n\n    vdots   vdots  vdots  ddots  vdots\n    y_m   z_m1  z_m2    z_mn\n  endmatrix\nendaligned","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"To get a better idea of the constructor functions, we are taking a look at example rhine_data_bicubic-nak.jl of this repo which reads two dimensional bottom topography data from a .txt file and does a bicubic B-spline interpolation with not-a-knot end condition and smoothing of the data.","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"# Include packages\nusing TrixiBottomTopography\nusing Plots\n\n# Get root directory\ndir_path = pkgdir(TrixiBottomTopography)\n\n# Define data path\ndata = string(dir_path, \"/examples/data/rhine_data_2d_20.txt\")\n\n# Define B-spline structure\nspline_struct = BicubicBSpline(data; end_condition = \"not-a-knot\", smoothing_factor = 9999)","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"For the bicubic case we can also set the optional parameters end_condition which defines (as the name suggests) the end condition of the spline. As in the one dimensional case, there are  the not-a-knot and the free end condition implemented. By default, end_condition is set to free. If you are not familiar with the differences between these end conditions, see Chapter 2 of","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Quentin Agrapart & Alain Batailly (2020),","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Cubic and bicubic spline interpolation in Python.  hal-03017566v2","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Besides the end condition, in the bicubic case, we can also specify a smoothing_factor, which defines trade-off degree of the cubic B-spline interpolation of goodness of fit and minimizing the curvature by defining new y values. This proceedure is called thin plate spline. There is no general approach which smoothing_factor is best suited for the problem and has to be determined via trial and error. To understand the underlying maths, please see:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Gianluca Donato and Serge Belongie (2001), Approximate Thin Plate Spline Mappings DOI: 10.1007/3-540-47977-5_2","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"In the next chapter, we are going to continue with the presented example.","category":"page"},{"location":"#TrixiBottomTopography.jl","page":"Home","title":"TrixiBottomTopography.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl is a supplementary package to the numerical solver Trixi.jl which enables to use real life geographical data for the bottom topography function of the shallow water equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The shallow water equations in one dimension","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nbeginpmatrix h  hv endpmatrix_t \n+ beginpmatrix hv  hv^2 + frac12gh^2 endpmatrix_x \n= beginpmatrix 0 -ghb_x endpmatrix\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"and two dimensions","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nbeginpmatrix h  hv_1  hv_2 endpmatrix_t \n+ beginpmatrix hv_1  hv_1^2 + frac12gh^2  hv_1v_2 endpmatrix_x\n+ beginpmatrix hv_2  hv_1v_2  hv_2^2 + frac12gh^2  endpmatrix_y\n= beginpmatrix 0 -ghb_x  -ghb_y endpmatrix\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"require a (piecewise) differentiable function b which describes the bottom topography.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Geographical data is almost always given as scattered data points on a coordinate system with corresponding elevation. So to incorporate geographical data into the shallow water equations, we need to define a function, which remodels the topography from the data. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl does this by B-spline interpolation of the underlying data.","category":"page"},{"location":"#Functionalities","page":"Home","title":"Functionalities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains the following three main functionalities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Converting geographical data given in form of .xyz files from the DGM data set provided by Geobasis NRW to make it readable for TrixiBottomTopography.jl\nSetting up a B-spline interpolation structure in one and two dimensions which contains all the relevant information to define a B-spline interpolation function with additional specifications\nUsing the B-spline structure to set up a B-spline interpolation function ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A detailed description of the functionalities can be found on the following pages.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some examples which use the implemented functionalities, see the examples folder of this repository.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl was developed and is maintained by Maximilian Dominique Bertrand (University of Cologne, Germany). ","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl is published under the MIT license (see License). We are very happy to accept contributions from everyone, preferably in the form of a PR.","category":"page"},{"location":"function/#B-spline-interpolation-function","page":"B-spline function","title":"B-spline interpolation function","text":"","category":"section"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"If the the B-spline structure is defined, it can be used to define the B-spline interpolation function. In this chapter, we are goin to continue with the examples in the previous chapter for the one and two dimensional case.","category":"page"},{"location":"function/#One-dimensional-case","page":"B-spline function","title":"One dimensional case","text":"","category":"section"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"In the previous chapter we started looking at the example file rhine_data_cubic-nak.jl from the examples folder where we already defined the B-spline structure for the cubic B-spline interpolation with not-a-knot end condition and smoothing.","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Include packages\nusing TrixiBottomTopography\nusing Plots\n\n# Get root directory\ndir_path = pkgdir(TrixiBottomTopography)\n\n# Define data path\ndata = string(dir_path, \"/examples/data/rhine_data_1d_20_x.txt\")\n\n# Define B-spline structure\nspline_struct = CubicBSpline(data; end_condition = \"not-a-knot\", smoothing_factor = 999)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"To define the B-spline interpolation function with respect to a variable x, we use the spline_interpolation function which for the one dimensional case which is implemented as spline_interpolation(linear_struct, x) and spline_interpolation(cubic_struct, x).","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Define B-spline interpolation function\nspline_func(x) = spline_interpolation(spline_struct, x)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"This defines the cubic B-spline interpolation function with not-a-knot end condition and smoothing with respect to variable x. If we want to visualize the interpolation function with 100 interpolation points, we define:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Define interpolation points\nn = 100\nx_int_pts = Vector(LinRange(spline_struct.x[1], spline_struct.x[end], n))","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"and receive the corresponding y values by:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Get interpolated values\ny_int_pts = spline_func.(x_int_pts)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"Plotting the interpolated points, using ","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Plotting\npyplot()\nplot(x_int_pts, y_int_pts,\n     xlabel=\"ETRS89 East\", ylabel=\"DHHN2016 Height\",\n     label=\"Bottom topography\", \n     title=\"Cubic B-spline interpolation with not-a-knot end condition and smoothing\")","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"gives the following representation:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"(Image: image)","category":"page"},{"location":"function/#Two-dimensional-case","page":"B-spline function","title":"Two dimensional case","text":"","category":"section"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"In the previous chapter we started looking at the example file rhine_data_bicubic-nak.jl from the examples folder where we already defined the B-spline structure for the bicubic B-spline interpolation with not-a-knot end condition and smoothing.","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Include packages\nusing TrixiBottomTopography\nusing Plots\n\n# Get root directory\ndir_path = pkgdir(TrixiBottomTopography)\n\n# Define data path\ndata = string(dir_path, \"/examples/data/rhine_data_2d_20.txt\")\n\n# Define B-spline structure\nspline_struct = BicubicBSpline(data; end_condition = \"not-a-knot\", smoothing_factor = 9999)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"To define the B-spline interpolation function with respect to a variables x and y, we use the spline_interpolation function which for the two dimensional case which is implemented as spline_interpolation(bilinear_struct, x, y) and spline_interpolation(bicubic_struct, x, y).","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Define B-spline interpolation function\nspline_func(x,y) = spline_interpolation(spline_struct, x, y)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"This defines the bicubic B-spline interpolation function with not-a-knot end condition and smoothing with respect to variables x and y. If we want to visualize the interpolation function with 100 interpolation points in each direction, we define:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Define interpolation points\nn = 100\nx_int_pts = Vector(LinRange(spline_struct.x[1], spline_struct.x[end], n))\ny_int_pts = Vector(LinRange(spline_struct.y[1], spline_struct.y[end], n))","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"To fill a matrix z_int_pts which contains the corresponding z values for x_int_pts and y_int_pts, we define a helperfunction fill_sol_mat:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Helperfunction to fill the solution matrix\n# Input parameters:\n#  - f: spline function\n#  - x: vector of x values\n#  - y: vector of y values\nfunction fill_sol_mat(f, x, y)\n    \n  # Get dimensions for solution matrix\n  n = length(x)\n  m = length(y)\n\n  # Create empty solution matrix\n  z = zeros(n,m)\n\n  # Fill solution matrix\n  for i in 1:n, j in 1:m\n    # Evaluate spline functions\n    # at given x,y values\n    z[j,i] = f(x[i], y[j])\n  end\n\n  # Return solution matrix\n  return z\nend","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"and receive the z_int_pts values by setting:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Get interpolated matrix\nz_int_pts = fill_sol_mat(spline_func, x_int_pts, y_int_pts)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"Plotting the interpolated values","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Plotting\npyplot()\nsurface(x_int_pts, y_int_pts, z_int_pts, camera=(-30,30),\n        xlabel=\"ETRS89\\n East\", ylabel=\"ETRS89\\n North\", zlabel=\"DHHN2016\\n Height\", \n        label=\"Bottom topography\", \n        title=\"Cubic B-spline interpolation with not-a-knot end condition\")","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"gives the following representation:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"(Image: image)","category":"page"}]
}
