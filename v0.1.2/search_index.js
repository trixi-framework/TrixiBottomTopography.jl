var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"TrixiBottomTopography.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact with one of the principal developers first (see Authors).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"TrixiBottomTopography.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"page"},{"location":"contributing/#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The following text was taken from https://developercertificate.org:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"development/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"This page contains some helpful information for the development of TrixiBottomTopography.jl. Further information about useful tools for package development in Julia can be found on the development page of the Trixi.jl docs.","category":"page"},{"location":"development/#Releasing-a-new-version-of-TrixiBottomTopography","page":"Development","title":"Releasing a new version of TrixiBottomTopography","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Check whether everything is okay, tests pass etc.\nSet the new version number in Project.toml according to the Julian version of semver. Commit and push.\nComment @JuliaRegistrator register on the commit setting the version number.\nJuliaRegistrator will create a PR with the new version in the General registry. Wait for it to be merged.\nIncrement the version number in Project.toml again with suffix -DEV. For example, if you have released version v0.2.0, use v0.2.1-DEV as new version number.","category":"page"},{"location":"development/#Preview-the-documentation","page":"Development","title":"Preview the documentation","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"You can build the documentation of TrixiBottomTopography.jl locally by running","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'\njulia --project=docs --color=yes docs/make.jl","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"from the TrixiBottomTopography.jl main directory. Then, you can look at the html files generated in docs/build. For PRs triggered from branches inside the TrixiBottomTopography.jl main repository previews of the new documentation are generated at https://trixi-framework.github.io/TrixiBottomTopography.jl/previews/PRXXX, where XXX is the number of the PR. Note, this does not work for PRs from forks for security reasons (since anyone could otherwise push arbitrary stuff, including malicious code).","category":"page"},{"location":"code_of_conduct/#code-of-conduct","page":"Code of Conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Andrew Winters, or any other of the principal developers responsible for enforcement listed in Authors. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/codeofconduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"page"},{"location":"testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"During the development of TrixiBottomTopography.jl, we rely on continuous testing to ensure that modifications or new features do not break existing functionality or add other errors. In the main TrixiBottomTopography.jl repository, this is facilitated by GitHub Actions, which allows to run tests automatically upon certain events. When, how, and what is tested by GitHub Actions is controlled by the workflow file .github/workflows/ci.yml. In TrixiBottomTopography.jl tests are triggered by","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"each git push to main and\neach git push to any pull request.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"Besides checking functionality, we also analyze the Test coverage to ensure that we do not miss important parts during testing.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"note: Test and coverage requirements\nBefore merging a pull request (PR) to main, we require thatthe code passes all functional tests\ncode coverage does not decrease.","category":"page"},{"location":"testing/#Testing-setup","page":"Testing","title":"Testing setup","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"The entry point for all testing is the file test/runtests.jl, which is run by the automated tests and which can be triggered manually by executing","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"julia> using Pkg; Pkg.test(\"TrixiBottomTopography\")","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"in the REPL. Since there already exist many tests, we have split them up into multiple files in the test directory to allow for faster testing of individual parts of the code. Thus in addition to performing all tests, you can also just include one of the files named test_xxx.jl to run only a specific subset, e.g.,","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"julia> # Run all test for the TreeMesh1D\n       include(joinpath(\"test\", \"test_tree_1d.jl\"))","category":"page"},{"location":"testing/#Adding-new-tests","page":"Testing","title":"Adding new tests","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"We use Julia's built-in unit testing capabilities to configure tests. In general, newly added code must be covered by at least one test, and all new scripts added to the examples/ directory must be used at least once during testing. New tests should be added to the corresponding test/test_xxx.jl file. Please study one of the existing tests and stay consistent to the current style when creating new tests.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"Since we want to test as much as possible, we have a lot of tests and frequently create new ones. Therefore, new tests should be as short as reasonably possible, i.e., without being too insensitive to pick up changes or errors in the code.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"When you add new tests, please check whether all CI jobs still take approximately the same time. If the job where you added new tests takes much longer than everything else, please consider moving some tests from one job to another (or report this incident and ask the main developers for help).","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"note: Test duration\nAs a general rule, tests should last no more than 10 seconds when run with a single thread and after compilation (i.e., excluding the first run).","category":"page"},{"location":"testing/#Test-coverage","page":"Testing","title":"Test coverage","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"In addition to ensuring that the code produces the expected results, the automated tests also record the code coverage. The resulting coverage reports, i.e., which lines of code were executed by at least one test and are thus considered \"covered\" by testing, are automatically uploaded to Coveralls for easy analysis. Typically, you see a number of Coveralls results at the bottom of each pull request: One for each parallel job (see Testing setup), which can usually be ignored since they only cover parts of the code by definition, and a cumulative coverage result named coverage/coveralls. The \"Details\" link takes you to a detailed report on which lines of code are covered by tests, which ones are missed, and especially which new lines the pull requests adds to TrixiBottomTopography.jl's code base that are not yet covered by testing.","category":"page"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"TrixiBottomTopography.jl follows the interpretation of semantic versioning (semver) used in the Julia ecosystem. Notable changes will be documented in this file for human readability.","category":"page"},{"location":"changelog/#Changes-in-the-v0.1-lifecycle","page":"Changelog","title":"Changes in the v0.1 lifecycle","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Implementation of visualization routines plot_topography and plot_topography_with_interpolation_knots","category":"page"},{"location":"changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The required Julia version is updated to v1.10.\nVisualization routines rely on Makie.jl instead of PyPlot.jl #52","category":"page"},{"location":"changelog/#Deprecated","page":"Changelog","title":"Deprecated","text":"","category":"section"},{"location":"changelog/#Removed","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"authors/#trixi_bt_authors","page":"Authors","title":"Authors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"TrixiBottomTopography.jl's development was initiated by Maximilian D. Bertrand. Its development and maintenance is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about TrixiBottomTopography.jl. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The TrixiBottomTopography.jl Authors\" as mentioned under License.","category":"page"},{"location":"authors/#Principal-Developers","page":"Authors","title":"Principal Developers","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"Maximilian D. Bertrand University of Cologne, Germany\nAndrew Winters, Linköping University, Sweden","category":"page"},{"location":"authors/#Contributors","page":"Authors","title":"Contributors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"The following people contributed major additions or modifications to TrixiBottomTopography.jl and are listed in alphabetical order:","category":"page"},{"location":"authors/","page":"Authors","title":"Authors","text":"Maximilian D. Bertrand\nHendrik Ranocha\nMichael Schlottke-Lakemper\nAndrew Winters","category":"page"},{"location":"reference/#TrixiBottomTopography.jl-API","page":"Reference","title":"TrixiBottomTopography.jl API","text":"","category":"section"},{"location":"reference/#TrixiBottomTopography.TrixiBottomTopography","page":"Reference","title":"TrixiBottomTopography.TrixiBottomTopography","text":"TrixiBottomTopography\n\nTrixiBottomTopography.jl is a supporting framework for Trixi.jl and TrixiShallowWater.jl, which can be used to approximate bottom topography functions using B-splines from real world data.\n\n\n\n\n\n","category":"module"},{"location":"reference/#TrixiBottomTopography.BicubicBSpline","page":"Reference","title":"TrixiBottomTopography.BicubicBSpline","text":"BicubicBSpline(x, y, Delta, Q, IP)\n\nTwo dimensional cubic B-spline structure that contains all important attributes to define a B-Spline interpolation function. These attributes are:\n\nx: Vector of values in x-direction\ny: Vector of values in y-direction\nDelta: Length of one side of a single patch in the given data set. A patch is the area between          two consecutive x and y values. The value Delta corresponds to the distance between          two consecutive values in x-direction. As we are only considering Cartesian grids,          Delta is equal for all patches in x and y-direction\nQ: Matrix which contains the control points\nIP: Coefficients matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#TrixiBottomTopography.BicubicBSpline-Tuple{String}","page":"Reference","title":"TrixiBottomTopography.BicubicBSpline","text":"BicubicBSpline(path::String; end_condition = \"free\", smoothing_factor = 0.0)\n\nA function which reads in the x, y and z values for BilinearBSpline from a .txt file. The input values are:\n\npath: String of a path of the specific .txt file\nend_condition: String which can either be \"free\" or \"not-a-knot\" and defines which                  end condition should be considered.                  By default this is set to \"free\"\nsmoothing_factor: Float64 geq 0.0 which specifies the degree of smoothing of the y values.                     By default this value is set to 0.0 which corresponds to no smoothing.\n\nThe .txt file has to have the following structure to be interpreted by this function:\n\nFirst line: comment # Number of x values\nSecond line: integer which gives the number of x values\nThird line: comment # Number of y values\nFourth line: integer which gives the number of y values\nFifth line: comment # x values\nFollowing lines: the x values where each value has its own line\nLine after the x-values: comment # y values\nFollowing lines: y values where each value has its own line\nLine after the y-values: comment # z values\nRemaining lines: values for z where each value has its own line and is in th following order:                  z11, z12, ... z1n, z21, ... z2n, ..., zm1, ..., z_mn\n\nAn example can be found here\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.BicubicBSpline-Tuple{Vector, Vector, Matrix}","page":"Reference","title":"TrixiBottomTopography.BicubicBSpline","text":"BicubicBSpline(x::Vector, y::Vector, z::Matrix; end_condition = \"free\", smoothing_factor = 0.0)\n\nThis function calculates the inputs for the structure BicubicBSpline. The input values are:\n\nx: Vector that contains equally spaced values in x-direction\ny: Vector that contains equally spaced values in y-direction where the spacing between the      y-values has to be the same as the spacing between the x-values\nz: Matrix that contains the corresponding values in z-direction.      Where the values are ordered in the following way:\n\nbeginaligned\n    beginmatrix\n          x_1  x_2    x_n\n            \n        y_1   z_11  z_12    z_1n\n        y_1   z_21  z_22    z_2n\n        vdots   vdots  vdots  ddots  vdots\n        y_m   z_m1  z_m2    z_mn\n    endmatrix\nendaligned\n\nend_condition: a string which can either be \"free\" or \"not-a-knot\" and defines which                  end condition should be considered. By default this is set to \"free\".\nsmoothing_factor: a Float64 geq 0.0 which specifies the degree of smoothing of the z                     values. By default this value is set to 0.0 which corresponds to no                     smoothing.\n\nBicubic B-spline interpolation is only possible if the dimensions of vectors x and y correspond with the dimensions of the matrix z.\n\nFirst, the data is sorted via sort_data to guarantee that the x and y values are in ascending order with corresponding matrix z.\n\nThe patch size Delta is calculated by subtracting the second by the first x value. This can be done because we only consider equal space between consecutive x and y values. A patch is the area between two consecutive x and y values.\n\nIf a smoothing_factor  0.0 is set, the function calc_tps calculates new values for z which guarantee a resulting parametric B-spline surface with less curvature.\n\nThe coefficients matrix IP for bicubic B-splines is fixed to be\n\nbeginaligned\n    beginpmatrix\n        -1  3  -3  1\n        3  -6  3  0\n        -3  0  3  0\n        1  4  1  0\n    endpmatrix\nendaligned\n\nTo get the matrix of control points Q which is necessary to set up an interpolation function, we need to define a matrix Phi which maps the control points to a vector P. This can be done by solving the following system of linear equations for Q.\n\nunderbrace\n    beginbmatrix\n        z_11  z_12  vdots  z_1n  z_21  vdots  z_mn  0  vdots  0\n    endbmatrix\n    _text=P in mathbbR^(m+2)(n+2)times 1 = frac136\n    Phi cdot\n    underbracebeginbmatrix\n        Q_11  Q_12  vdots  Q_1n+2  Q_21  vdots  Q_m+2n+2\n    endbmatrix_text= Q in mathbbR^(m+2) times (n+2)\n\nFor the first n cdot m lines, the matrix Phi is the same for the \"free\" end and the \"not-a-knot\" end condition. These lines have to address the following condition:\n\nbeginalign*\n    z_ji = frac136 Big( Q_ji + 4Q_j+1i + Q_j+2i + 4Q_ji+1 + 16Q_j+1i+1\n    + 4Q_j+2i+1 + Q_ji+2 + 4Q_j+1i+2 + Q_j+2i+2 Big)\nendalign*\n\nfor i = 1,...,n and j = 1,...,m.\n\nThe \"free\" end condition needs at least two values for the x and y vectors. The \"free\" end condition has the following additional requirements for the control points which have to be addressed by Phi:\n\nQ_j1 - 2Q_j2 + Q_j3 = 0 for j = 2,...,m+1\nQ_jn - 2Q_jn+1 + Q_jn+2 = 0 for j = 2,...,m+1\nQ_1i - 2Q_2i + Q_3i = 0 for i = 2,...,n+1\nQ_mi - 2Q_m+1i + Q_m+2i = 0 for i = 2,...,n+1\nQ_11 - 2Q_22 + Q_33 = 0\nQ_m+21 - 2Q_m+12 + Q_m3 = 0\nQ_1n+2 - 2Q_2n+1 + Q_3n = 0\nQ_mn - 2Q_m+1n+1 + Q_m+2n+2 = 0\n\nThe \"not-a-knot\" end condition needs at least four values for the x and y vectors.\n\nContinuity of the third x derivative between the leftmost and second leftmost patch\nContinuity of the third x derivative between the rightmost and second rightmost patch\nContinuity of the third y derivative between the patch at the top and the patch below\nContinuity of the third y derivative between the patch at the bottom and the patch above\nQ_11 - Q_12 - Q_21 + Q_22 = 0\nQ_m-11 + Q_m1 + Q_m-12 - Q_m2 = 0\nQ_1n-1 + Q_2n + Q_1n-1 - Q_2n = 0\nQ_m-1n-1 - Q_mn-1 - Q_m-1n + Q_mn = 0\n\nA reference for the calculations in this script can be found in Chapter 2 of\n\nQuentin Agrapart & Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.BilinearBSpline","page":"Reference","title":"TrixiBottomTopography.BilinearBSpline","text":"BilinearBSpline(x, y, Delta, Q, IP)\n\nTwo dimensional bilinear B-spline structure that contains all important attributes to define a B-Spline interpolation function. These attributes are:\n\nx: Vector of values in x-direction\ny: Vector of values in y-direction\nDelta: Length of one side of a single patch in the given data set. A patch is the area between          two consecutive x and y values. The value Delta corresponds to the distance          between two consecutive values in x-direction. As we are only considering Cartesian          grids, Delta is equal for all patches in x and y-direction\nQ: Matrix which contains the control points\nIP: Coefficients matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#TrixiBottomTopography.BilinearBSpline-Tuple{String}","page":"Reference","title":"TrixiBottomTopography.BilinearBSpline","text":"BilinearBSpline(path::String)\n\nA function which reads in the x, y and z values for BilinearBSpline from a .txt file. The input values are:\n\npath: String of a path of the specific .txt file\n\nThe .txt file has to have the following structure to be interpreted by this function:\n\nFirst line: comment # Number of x values\nSecond line: integer which gives the number of x values\nThird line: comment # Number of y values\nFourth line: integer which gives the number of y values\nFifth line: comment # x values\nFollowing lines: the x values where each value has its own line\nLine after the x-values: comment # y values\nFollowing lines: y values where each value has its own line\nLine after the y-values: comment # z values\nRemaining lines: values for z where each value has its own line and is in the following order:                  z11, z12, ... z1n, z21, ... z2n, ..., zm1, ..., z_mn\n\nAn example can be found here\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.BilinearBSpline-Tuple{Vector, Vector, Matrix}","page":"Reference","title":"TrixiBottomTopography.BilinearBSpline","text":"BilinearBSpline(x::Vector, y::Vector, z::Matrix)\n\nThis function calculates the inputs for the structure BilinearBSpline. The input values are:\n\nx: Vector that contains equally spaced values in x-direction\ny: Vector that contains equally spaced values in y-direction where the spacing between the      y-values has to be the same as the spacing between the x-values\nz: Matrix that contains the corresponding values in z-direction.      Where the values are ordered in the following way:\n\nbeginaligned\n   beginmatrix\n          x_1  x_2    x_n\n            \n        y_1   z_11  z_12    z_1n\n        y_1   z_21  z_22    z_2n\n        vdots   vdots  vdots  ddots  vdots\n        y_m   z_m1  z_m2    z_mn\n   endmatrix\nendaligned\n\nBilinear B-spline interpolation is only possible if we have at least two values in x and two values in y and the dimensions of vectors x and y correspond with the dimensions of the matrix z.\n\nFirst of all the data is sorted which is done by sort_data to guarantee that the x and y values are in ascending order with corresponding matrix z.\n\nThe patch size Delta is calculated by subtracting the second by the first x value. This can be done because we only consider equal space between consecutive x and y values. A patch is the area between two consecutive x and y values.\n\nFor bilinear B-spline interpolation, the control points Q correspond with the z values.\n\nThe coefficients matrix IP for bilinear B-splines is fixed to be\n\nbeginaligned\n  beginpmatrix\n    -1  1\n    1  0\n  endpmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 2 of\n\nQuentin Agrapart & Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.CubicBSpline","page":"Reference","title":"TrixiBottomTopography.CubicBSpline","text":"CubicBSpline(x, Delta, Q, IP)\n\nOne dimensional cubic B-spline structure that contains all important attributes to define a B-Spline interpolation function. Similar to LinearBSpline These attributes are:\n\nx: Vector of values in x-direction\nDelta: Length of a single patch in the given data set. A patch is the area between two          consecutive x values. The value Delta corresponds to the distance between two          consecutive values in x-direction. As we are only considering Cartesian grids, Delta          is equal for all patches\nQ: Vector which contains the Control points\nIP: Coefficients matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#TrixiBottomTopography.CubicBSpline-Tuple{String}","page":"Reference","title":"TrixiBottomTopography.CubicBSpline","text":"CubicBSpline(path::String; end_condition = \"free\", smoothing_factor = 0.0)\n\nA function that reads in the x and y values for CubicBSpline from a .txt file. The input values are:\n\npath: String of a path of the specific .txt file\nend_condition: String which can either be free or not-a-knot and defines which                  end condition should be considered.                  By default this is set to free\nsmoothing_factor: Float64 geq 0.0 which specifies the degree of smoothing of the y values.                     By default this value is set to 0.0 which corresponds to no smoothing.\n\nThe .txt file has to have the following structure to be interpreted by this function:\n\nFirst line: comment # Number of x values\nSecond line: integer which gives the number of x values\nThird line: comment # x values\nFollowing lines: the x values where each value has its own line\nLine after the x-values: comment # y values\nRemaining lines: y values where each value has its own line\n\nNote that the number of x and y values have to be the same. An example can be found here\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.CubicBSpline-Tuple{Vector, Vector}","page":"Reference","title":"TrixiBottomTopography.CubicBSpline","text":"CubicBSpline(x::Vector, y::Vector; end_condition = \"free\", smoothing_factor = 0.0)\n\nThis function calculates the inputs for the structure CubicBSpline. The input values are:\n\nx: Vector that contains equally spaces values in x-direction\ny: Vector that contains values in y-direction\nend_condition: String that can either be free or not-a-knot and defines which                  end condition should be considered. By default this is set to \"free\".\nsmoothing_factor: Float64 geq 0.0 which specifies the degree of smoothing of the y                     values. By default this value is set to 0.0 that corresponds to no                     smoothing.\n\nFirst the data is sorted via sort_data to guarantee that the x values are in ascending order.\n\nThe patch size Delta is calculated by subtracting the second and first x value. This can be done because we only consider equally spaced x values. (A patch is the area between two consecutive x values)\n\nIf a smoothing_factor > 0.0 is set, the function spline_smoothing calculates new y values which guarantee a B-Spline with less curvature.\n\nThe coefficients matrix IP for linear B-splines is fixed to be\n\nbeginaligned\n  IP = beginpmatrix\n    -1  3  -3  1\n    3  -6  3  0\n    -3  0  3  0\n    1  4  1  0\n  endpmatrix\nendaligned\n\nThe \"free\" end condition requires the second and the second to last control points lie between the first and the third control point and that the second to last control points are between the third to last and the last control point. This procedure is only possible with at least two values in x data. The system of linear equations to determine the control points have the following form:\n\nbeginaligned\n    underbracebeginbmatrix\n            0  P_1  P_2  vdots  P_n-1  P_n 0\n        endbmatrix_= P^*_textfree\n        = frac16\n    underbrace\n        beginbmatrix\n            1  -2  1  0      0 \n            1       4  1  0      0\n            0       1  4  1  0             vdots\n            vdots   0       ddots  ddots  ddots  0  vdots\n            vdots         0  1  4  1  0\n            0      0  1  4  1\n            0      0  1  -2  1\n        endbmatrix\n    _= Phi^*_textfree\n    underbracebeginbmatrix\n        Q_1  Q_2  Q_3  vdots  Q_n  Q_n+1  Q_n+2\n    endbmatrix_= Q_textfree\nendaligned\n\nwhich is solved for Q_textfree.\n\nThe \"not-a-knot\" end condition requires the continuity of the third derivative in the second and second to last fit knot. This end condition is only possible with at least four values in x data. The system of linear equations to determine the control points has the following form:\n\nbeginaligned\n    underbracebeginbmatrix\n        0  P_1  P_2  vdots  P_n-1  P_n 0\n    endbmatrix_= P^*_textnot-a-knot\n    = frac16\n    underbrace\n        beginbmatrix\n            -1  4  -6  4  -1  0    0 \n            1       4  1  0        0\n            0       1  4  1  0             vdots\n            vdots   0       ddots  ddots  ddots  0  vdots\n            vdots    0       ddots  ddots  ddots  0 vdots\n            vdots         0  1  4  1  0\n            0         0  1  4  1\n            0    0  -1  4  -6  4  -1\n        endbmatrix\n    _= Phi^*_textnot-a-knot\n    underbracebeginbmatrix\n        Q_1  Q_2  Q_3  vdots  vdots  Q_n  Q_n+1  Q_n+2\n    endbmatrix_= Q_textnot-a-knot\nendaligned\n\nwhich is solved for Q_textnot-a-knot.\n\nFor both cases P_1P_n = y_1y_n.\n\nA reference for the calculations in this script can be found in Chapter 1 of\n\nQuentin Agrapart & Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.  hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.LinearBSpline","page":"Reference","title":"TrixiBottomTopography.LinearBSpline","text":"LinearBSpline(x, Delta, Q, IP)\n\nOne dimensional linear B-spline structure which contains all important attributes to define a B-Spline interpolation function. These attributes are:\n\nx: Vector of values in x-direction\nDelta: Length of a single patch in the given data set. A patch is the area between two          consecutive x values. The value Delta corresponds to the distance between two          consecutive values in x-direction. As we are only considering Cartesian grids,          Delta is equal for all patches\nQ: Vector which contains the control points\nIP: Coefficients matrix\n\n\n\n\n\n","category":"type"},{"location":"reference/#TrixiBottomTopography.LinearBSpline-Tuple{String}","page":"Reference","title":"TrixiBottomTopography.LinearBSpline","text":"LinearBSpline(path::String)\n\nA function that reads in the x and y values for LinearBSpline from a .txt file. The input values are:\n\npath: String of a path of the specific .txt file\n\nThe .txt file has to have the following structure to be interpreted by this function:\n\nFirst line: comment # Number of x values\nSecond line: integer which gives the number of x values\nThird line: comment # x values\nFollowing lines: the x values where each value has its own line\nLine after the x-values: comment # y values\nRemaining lines: y values where each value has its own line\n\nNote that the number of x and y values have to be the same. An example can be found here\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.LinearBSpline-Tuple{Vector, Vector}","page":"Reference","title":"TrixiBottomTopography.LinearBSpline","text":"LinearBSpline(x::Vector, y::Vector)\n\nThis function calculates the inputs for the structure LinearBSpline. The input values are:\n\nx: A vector that contains equally spaced values in x-direction\ny: A vector that contains values in y-direction\n\nLinear B-spline interpolation is only possible if the data set has at least two values in x.\n\nFirst the data is sorted via sort_data to guarantee that the x values are in ascending order.\n\nThe patch size Delta is calculated by subtracting the second and first x values. This can be done because we only consider equally spaced x values. A patch is the area between two consecutive x values.\n\nFor linear B-spline interpolation, the control points Q correspond with the values in y.\n\nThe coefficients matrix IP for linear B-splines is fixed to be\n\nbeginaligned\n  beginpmatrix\n    -1  1\n    1  0\n  endpmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 1 of\n\nQuentin Agrapart & Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.  hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.calc_tps-Tuple{Number, Vector, Vector, Matrix}","page":"Reference","title":"TrixiBottomTopography.calc_tps","text":"calc_tps(lambda::Number, x::Vector, y::Vector, z::Matrix)\n\nThe inputs to this function are:\n\nlambda: Smoothing factor which specifies the degree of the smoothing that should take place\nx: Vector of x values\ny: Vector of x values\nz: Matrix with the z values to be smoothed where the values of z correspond to the      indexing (y,x)\n\nThis function uses the thin plate spline approach to perform the smoothing. To do so, the following linear equations system has to be solved for coeff:\n\nbeginaligned\n    underbrace\n        beginbmatrix\n            K  P \n            P^T  O\n        endbmatrix\n    _= L\n    underbrace\n        beginbmatrix\n            w  a\n        endbmatrix_text= coeff\n    \n        =\n    underbrace\n        beginbmatrix\n            zo\n        endbmatrix_text= rhs\n    \nendaligned\n\nFirst, the inputs are restructured using the function restructure_data and saved in the variables x_hat, y_hat and z_hat.\n\nThen the matrix L can be filled by setting K = tps_base_func(||(x_hat[i], y_hat[i]) - (x_hat[j], y_hat[j])||) where || || is the Euclidian norm, P = [1 x y] and O = 3times 3 zeros matrix.\n\nAfterwards the vector rhs is filled by setting z = z_hat and o = a vector with three zeros.\n\nNow the system is solved to redeem the vector coeff. This vector is then used to calculate the smoothed values for z and save them in H_f by the following function:\n\nbeginalign*\nz_smthi = a1 + a2x_hati + a3y_hati \n        + sum_j = 0^p wj tps_base_func((x_hati y_hati) - (x_hatj y_hatj) )\nendalign*\n\nhere p is the number of entries in z_hat.\n\nA reference to the calculations can be found in the lecture notes of\n\nGianluca Donato and Serge Belongie (2001), Approximate Thin Plate Spline Mappings DOI: 10.1007/3-540-47977-5_2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.convert_dgm_1d-Tuple{String, String}","page":"Reference","title":"TrixiBottomTopography.convert_dgm_1d","text":"convert_dgm_1d(path_read::String, path_write::String; excerpt = 1, direction = \"x\", section = 1)\n\nFunction to convert DGM data files into one dimensional readable files.\n\nInputs:\n\npath_read: String of the path of the DGM data which should be converted\npath_write: String of the path where the new file should be saved.             (Needs to also include the name of the file)\nexcerpt: Optional integer that specifies a stride through of the data that will be extracted. E.g.          if excerpt is set to 10, only every 10th x and y value are considered with their          corresponding z values. The default value is 1 which means that every value is taken.\ndirection: Optional String that specifies if the one dimensional data should be read from the            x or y direction. By default this is set to the x direction.\nsection: Optional integer which can be between 1 and 1000 and specifies which section of the          other dimension should be chosen. By default this values is set to 1 which means          that if direction is set to x, the corresponding z values are taken with respect to the          first y value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.convert_dgm_2d-Tuple{String, String}","page":"Reference","title":"TrixiBottomTopography.convert_dgm_2d","text":"convert_dgm_2d(path_read::String, path_write::String; excerpt = 1)\n\nFunction to convert DGM data files into two dimensional readable files.\n\nInputs:\n\npath_read: String of the path of the DGM data which should be converted\npath_write: String of the path where the new file should be saved.             (Needs to also include the name of the file)\nexcerpt: Optional integer that specifies a stride through of the data that will be extracted. E.g.          if excerpt is set to 10, only every 10th x and y value are considered with their          corresponding z values. The default value is 1 which means that every value is taken.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.default_example-Tuple{}","page":"Reference","title":"TrixiBottomTopography.default_example","text":"TrixiBottomTopography.default_example()\n\nFunction which calls the example file \"rhinedatabicubic-nak.jl\" to check if including the package has worked. The example script creates a bicubic B-spline with the \"not-a-knot\" boundary condition. If a Makie.jl backend such as GLMakie.jl is included a plot will be generated as well.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.restructure_data-Tuple{Vector, Vector, Matrix}","page":"Reference","title":"TrixiBottomTopography.restructure_data","text":"  restructure_data(x::Vector, y::Vector, z::Matrix)\n\nThis function restructures the input values\n\nx: a vector with n values in x-direction\ny: a vector with m values in y-direction\nz: a  m times n matrix with values in z-direction where the values of z correspond      to the indexing (y,x)\n\nThe output is of the following form:\n\nbeginaligned\n    beginbmatrix\n        x_1  y_1  z_11\n        x_2  y_1  z_12\n         vdots  \n        x_n  y_1  z_1n\n        x_1  y_2  z_21\n         vdots  \n        x_n  y_m  z_mn\n    endbmatrix\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.sort_data-Tuple{Vector, Vector, Matrix}","page":"Reference","title":"TrixiBottomTopography.sort_data","text":"sort_data(x::Vector, y::Vector, z::Matrix)\n\nThis function sorts the inputs vectors x and y in a ascending order and also reorders the input matrix z accordingly.\n\nTherefore, first the x values are sorted with the matrix z accordingly and afterwards the y values are sorted with the matrix z accordingly.\n\nThe sorted x, y and z values are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.sort_data-Tuple{Vector, Vector}","page":"Reference","title":"TrixiBottomTopography.sort_data","text":"sort_data(x::Vector,y::Vector)\n\nSorts the input vectors x and y so that x is in ascending order and the y values accordingly to still correspond to the x values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_interpolation-Tuple{BicubicBSpline, Number, Number}","page":"Reference","title":"TrixiBottomTopography.spline_interpolation","text":"spline_interpolation(b_spline::BicubicBSpline, x::Number, y::Number)\n\nThe inputs are the BicubicBSpline object and the variable x and y at which the spline will be evaluated.\n\nThe parameters i and j indicate the patch in which (x,y) is located. This information is also used to get the correct control points from Q. A patch is the area between two consecutive b_spline.x and b_spline.y values.\n\nmy is  an interim variable which maps x to the interval 01 for further calculations. ny does the same for y.\n\nTo evaluate the spline at (x,y), we have to calculate the following:\n\nbeginaligned\nc_ij3(mu_i(x)nu_j(y)) = frac136\n    beginbmatrix nu_j^3(y)  nu_j^2(y)  nu_j(y)  1 endbmatrix^T\n    underbracebeginbmatrix\n        -1  3  -3  1\n        3  -6  3  0\n        -3  0  3  0\n        1  4  1  0\n    endbmatrix_textIP\n    beginbmatrix\n        Q_ij  Q_i+1j  Q_i+2j  Q_i+3j\n        Q_ij+1  Q_i+1j+1  Q_i+2j+1  Q_i+3j+1\n        Q_ij+2  Q_i+1j+2  Q_i+2j+2  Q_i+3j+2\n        Q_ij+3  Q_i+1j+3  Q_i+2j+3  Q_i+3j+3\n    endbmatrix\n    underbracebeginbmatrix\n        -1  3  -3  1\n        3  -6  0  4\n        -3  3  3  1\n        1  0  0  0\n    endbmatrix_textIP\n    beginbmatrix mu_i^3(x)  mu_i^2(x)  mu_i(x)  1 endbmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 2 of\n\nQuentin Agrapart & Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.  hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_interpolation-Tuple{BilinearBSpline, Number, Number}","page":"Reference","title":"TrixiBottomTopography.spline_interpolation","text":"spline_interpolation(b_spline::BilinearBSpline, x::Number, y::Number)\n\nThe inputs are the BilinearBSpline object and the variable x and y at which the spline will be evaluated.\n\nThe parameters i and j indicate the patch in which (x,y) is located. This information is also used to get the correct control points from Q. A patch is the area between two consecutive b_spline.x and b_spline.y values.\n\nmy is  an interim variable that maps x to the interval 01 for further calculations. ny does the same for y.\n\nTo evaluate the spline at (x,y), we have to calculate the following:\n\nbeginaligned\nc_ij1(mu_i(x)nu_j(y)) =\n    beginbmatrix nu_j(y) 1 endbmatrix^T\n    underbracebeginbmatrix -1  1 1  0 endbmatrix_textIP\n    beginbmatrix Q_ij  Q_ij+1 Q_i+1j  Q_i+1j+1 endbmatrix\n    underbracebeginbmatrix -1  1 1  0 endbmatrix_textIP^T\n    beginbmatrix mu_i(x)  1endbmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 2 of\n\nQuentin Agrapart & Alain Batailly (2020) Cubic and bicubic spline interpolation in Python. hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_interpolation-Tuple{CubicBSpline, Number}","page":"Reference","title":"TrixiBottomTopography.spline_interpolation","text":"spline_interpolation(b_spline::CubicBSpline, x::Number)\n\nThe inputs are the CubicBSpline object and a variable x at which the spline will be evaluated.\n\nThe parameter i indicates the patch in which the variable x is located. This parameter is also used to get the correct control points from Q. A patch is the area between two consecutive b_spline.x values.\n\nkappa is  an interim variable which maps t to the interval 01 for further calculations.\n\nTo evaluate the spline at x, we have to calculate the following:\n\nbeginaligned\nc_i3left(kappa_i(x) right) = frac16\n    beginbmatrix\n        kappa_i(x)^3 kappa_i(x)^2 kappa_i(x) 1\n    endbmatrix^T\n    underbracebeginbmatrix\n        -1  3  -3  1\n        3  -6  3  0\n        -3  0  3  0\n        1  4  1  0\n    endbmatrix_textIP\n    beginbmatrix\n        Q_itextfree Q_i+1textfree Q_i+2textfree Q_i+3textfree\n    endbmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 1 of\n\nQuentin Agrapart & Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_interpolation-Tuple{LinearBSpline, Number}","page":"Reference","title":"TrixiBottomTopography.spline_interpolation","text":"spline_interpolation(b_spline::LinearBSpline, x::Number)\n\nThe inputs are the LinearBSpline object and a variable x at which the spline will be evaluated.\n\nThe parameter i indicates the patch in which the variable x is located. This parameter is also used to get the correct control points from Q. A patch is the area between two consecutive b_spline.x values.\n\nkappa is an interim variable which maps x to the interval 01 for further calculations.\n\nTo evaluate the spline at x, we have to calculate the following:\n\nbeginaligned\nc_i1(kappa_i(x)) =\n    beginbmatrix\n        kappa_i(x) 1\n    endbmatrix^T\n    beginbmatrix\n        -1  11  0\n    endbmatrix\n    beginbmatrix\n        Q_iQ_i+1\n    endbmatrix\nendaligned\n\nA reference for the calculations in this script can be found in Chapter 1 of\n\nQuentin Agrapart & Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. hal-03017566v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.spline_smoothing-Tuple{Number, Number, Vector}","page":"Reference","title":"TrixiBottomTopography.spline_smoothing","text":"spline_smoothing(lambda::Number, Delta::Number, y::Vector)\n\nThe inputs to this function are:\n\nlambda: Smoothing factor which specifies the degree of the smoothing that should take place\nDelta: Step size of a patch (A patch is the area between two consecutive x values)\ny: Data values to be smoothed\n\nThe goal is to find a new interpolation values haty for y, so that for given lambda, the following equation is minimized:\n\nbeginaligned\n    textPSS = sum_i = 1^n left( y_i - underbraceS(t_i)_=haty_i right)^2\n    + lambda int_x_1^x_n (S(t))^2 dt\nendaligned\n\nwhere S(t) is a cubic spline function. haty is determined as follows:\n\nbeginaligned\n    haty = (I+lambda K)^-1 y\nendaligned\n\nwhere I is the n times n identity matrix and K = Delta_2^T W^-1 Delta_2 with\n\nbeginaligned\n    Delta_2 = beginpmatrix\n        1Delta  -2Delta  1Delta    0\n        0  ddots  ddots  ddots  0\n        0    1Delta  -2Delta  1Delta\n    endpmatrix in mathbbR^(n-2) times n\nendaligned\n\nand\n\nbeginaligned\n    W = beginpmatrix\n        23 Delta  16 Delta  0    0\n        16 Delta  23 Delta  16 Delta    0\n        0  ddots  ddots  ddots  0\n        0    0  23 Delta  16 Delta\n    endpmatrix in mathbbR^n times n\nendaligned\n\nGermán Rodríguez (2001), Smoothing and non-parametric regression\n\n\n\n\n\n","category":"method"},{"location":"reference/#TrixiBottomTopography.tps_base_func-Tuple{Number}","page":"Reference","title":"TrixiBottomTopography.tps_base_func","text":"tps_base_func(r::Number)\n\nThin plate spline basis function.\n\nGianluca Donato and Serge Belongie (2001) Approximate Thin Plate Spline Mappings DOI: 10.1007/3-540-47977-5_2\n\n\n\n\n\n","category":"method"},{"location":"function/#B-spline-interpolation-function","page":"B-spline function","title":"B-spline interpolation function","text":"","category":"section"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"If the B-spline structure is defined, it can be used to define the B-spline interpolation function. In this chapter, we will continue with the examples from the B-spline structure section for the one and two dimensional case.","category":"page"},{"location":"function/#One-dimensional-case","page":"B-spline function","title":"One dimensional case","text":"","category":"section"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"In the B-spline structure section, we began with the example file rhine_data_cubic-nak.jl from the examples folder where we already defined the B-spline structure for the cubic B-spline interpolation with not-a-knot end condition and smoothing.","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Include packages\nusing TrixiBottomTopography\nusing CairoMakie\n\n# Define data path\nroot_dir = pkgdir(TrixiBottomTopography)\ndata = joinpath(root_dir, \"examples\", \"data\", \"rhine_data_1d_20_x.txt\")\n\n# Define B-spline structure\nspline_struct = CubicBSpline(data; end_condition = \"not-a-knot\", smoothing_factor = 999)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"To define the B-spline interpolation function for a variable x, we use the spline_interpolation function. For the one dimensional case, this function is implemented as spline_interpolation(linear_struct, x) and spline_interpolation(cubic_struct, x).","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Define B-spline interpolation function\nspline_func(x) = spline_interpolation(spline_struct, x)\nnothing #hide","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"This defines the cubic B-spline interpolation function with not-a-knot end condition and smoothing with respect to variable x from the previously created spline_struct. If we want to visualize the interpolation function with 100 interpolation points, we define the following:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Define interpolation points\nn = 200\nx_int_pts = Vector(LinRange(spline_struct.x[1], spline_struct.x[end], n))","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"and evaluate to obtain the corresponding y values by:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Get interpolated values\ny_int_pts = spline_func.(x_int_pts)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"Plotting the interpolated points can be done via the command below and produces a one-dimensional plot","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"plot_topography(x_int_pts, y_int_pts; xlabel = \"ETRS89 East\", ylabel = \"DHHN2016 Height\")","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"Alternatively, one can plot the interpolated bottom topography together with the interpolation knots as follows","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Get the original interpolation knots\nx_knots = spline_struct.x\ny_knots = spline_func.(x_knots)\n\nplot_topography_with_interpolation_knots(x_int_pts, y_int_pts, x_knots, y_knots;\n                                         xlabel = \"ETRS89 East\", ylabel = \"DHHN2016 Height\")","category":"page"},{"location":"function/#Two-dimensional-case","page":"B-spline function","title":"Two dimensional case","text":"","category":"section"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"In the B-spline structure section, we examined the example file rhine_data_bicubic-nak.jl from the examples folder where we already created the B-spline structure for the bicubic B-spline interpolation with not-a-knot end condition and smoothing.","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Include packages\nusing TrixiBottomTopography\nusing CairoMakie\n\n# Define data path\nroot_dir = pkgdir(TrixiBottomTopography)\ndata = joinpath(root_dir, \"examples\", \"data\", \"rhine_data_2d_20.txt\")\n\n# Define B-spline structure\nspline_struct = BicubicBSpline(data; end_condition = \"not-a-knot\", smoothing_factor = 9999)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"To define the B-spline interpolation function for variables x and y, we use the spline_interpolation function for the two dimensional case. This functionality is implemented as spline_interpolation(bilinear_struct, x, y) and spline_interpolation(bicubic_struct, x, y).","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Define B-spline interpolation function\nspline_func(x,y) = spline_interpolation(spline_struct, x, y)\nnothing #hide","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"This defines the bicubic B-spline interpolation function with not-a-knot end condition and smoothing for variables x and y due to the previously constructed spline_struct. If we want to visualize the bicubic interpolation function with 100 interpolation points in each spatial direction, we define:","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Define interpolation points\nn = 100\nx_int_pts = Vector(LinRange(spline_struct.x[1], spline_struct.x[end], n))\ny_int_pts = Vector(LinRange(spline_struct.y[1], spline_struct.y[end], n))","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"To fill a matrix z_int_pts, which contains the corresponding z values for x_int_pts and y_int_pts, we use the helper function evaluate_bicubicspline_interpolant.","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Get interpolated matrix\nz_int_pts = evaluate_bicubicspline_interpolant(spline_func, x_int_pts, y_int_pts)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"Plotting the interpolated values gives the representation directly below the plot_topography command","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"plot_topography(x_int_pts, y_int_pts, z_int_pts;\n                xlabel=\"ETRS89\\n East\",\n                ylabel=\"ETRS89\\n North\",\n                zlabel=\"DHHN2016\\n Height\",\n                azimuth_angle = 54 * pi / 180,\n                elevation_angle = 27 * pi / 180)","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"Alternatively, one can plot the interpolated two-dimensional bottom topography together with the interpolation knots as follows","category":"page"},{"location":"function/","page":"B-spline function","title":"B-spline function","text":"# Get the original interpolation knots\nx_knots = spline_struct.x\ny_knots = spline_struct.y\nz_knots = evaluate_bicubicspline_interpolant(spline_func, x_knots, y_knots)\n\nplot_topography_with_interpolation_knots(x_int_pts, y_int_pts, z_int_pts,\n                                         x_knots, y_knots, z_knots;\n                                         xlabel=\"ETRS89\\n East\",\n                                         ylabel=\"ETRS89\\n North\",\n                                         zlabel=\"DHHN2016\\n Height\",\n                                         azimuth_angle = 54 * pi / 180,\n                                         elevation_angle = 27 * pi / 180)","category":"page"},{"location":"trixi_jl_examples/#Examples-with-Trixi.jl","page":"Trixi.jl examples","title":"Examples with Trixi.jl","text":"","category":"section"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"As mentioned in the Home section of this documentation, TrixiBottomTopography.jl was initially developed as a supplementary package for the numerical solver Trixi.jl to enable the user to use real world geographical data for the bottom topography function of the shallow water equations. TrixiBottomTopography.jl can also be used together with TrixiShallowWater.jl a solver suite specifically designed for shallow water flow applications. An example that combines TrixiBottomTopography.jl with wet/dry transitions and shock capturing to model a tsunami runup is available as a tutorial in TrixiShallowWater.jl.","category":"page"},{"location":"trixi_jl_examples/#One-dimensional-dam-break","page":"Trixi.jl examples","title":"One dimensional dam break","text":"","category":"section"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"In this section, a one dimensional example is presented which uses the functionalities of TrixiBottomTopography.jl with Trixi.jl to simulate a dam break problem.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The underlying example file can be found here.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"First, all the necessary packages must be included at the beginning of the file.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# Include packages\nusing TrixiBottomTopography\nusing CairoMakie\nusing OrdinaryDiffEqLowStorageRK\nusing Trixi","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"CairoMakie.jl is the Makie.jl backend responsible for visualizing the approximate solution of the dam break problem.\nOrdinaryDiffEqLowStorageRK.jl is a sub-package of OrdinaryDiffEq.jl that must be added to load low-storage explicit Runge-Kutta methods to be used by Trixi.jl.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"Next, the underlying bottom topography data is downloaded from a gist.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# Download one dimensional Rhine bottom data from gist\nRhine_data = download(\"https://gist.githubusercontent.com/maxbertrand1996/19c33682b99bfb1cc3116f31dd49bdb9/raw/d96499a1ffe250bc8e4cca8622779bae61543fd8/Rhine_data_1D_40_x_841.txt\")\nnothing #hide","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The downloaded data is then used to define the B-spline interpolation function as described in B-spline structure and B-spline function. In this case, a cubic B-spline interpolation function with free end condition is chosen.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# B-spline interpolation of the underlying data.\n# The type of this struct is fixed as `CubicBSpline`.\nconst spline_struct = CubicBSpline(Rhine_data)\nspline_func(x::Float64) = spline_interpolation(spline_struct, x)","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"Now that the B-spline interpolation function is determined, the one dimensional shallow water equations implemented in Trixi.jl can be defined by calling:","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# Defining one dimensional shallow water equations\nequations = ShallowWaterEquations1D(gravity_constant = 1.0, H0 = 55.0)","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"Here the gravity constant has been chosen to be 10, and the background total water height H_0 has been set to 550.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"Next, the initial condition for the dam break problem can be defined. At time t=0, a part of the water height in the center of the domain with a diameter of 100 is set to 600 while the rest of the domain stays at the background water height 550. Additionally, we can see that the bottom topography b is defined by the B-spline interpolation function spline_func and is set in the initial condition.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# Defining initial condition for the dam break problem\nfunction initial_condition_dam_break(x, t, equations::ShallowWaterEquations1D)\n\n  inicenter = SVector(357490.0)\n  x_norm = x[1] - inicenter[1]\n  r = abs(x_norm)\n\n  # Calculate primitive variables\n  H = r < 50 ? 60.0 : 55.0\n  v = 0.0\n  b = spline_func(x[1])\n\n  return prim2cons(SVector(H, v, b), equations)\nend","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"After the initial condition, we can set the boundary conditions. In this case, a reflective wall condition is chosen, which is already implemented in Trixi.jl for the one dimensional shallow water equations.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# Setting initial condition\ninitial_condition = initial_condition_dam_break\n\n# Setting the boundary to be a reflective wall\nboundary_condition = boundary_condition_slip_wall","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The upcoming code parts will not be covered in full detail. To get a more profound understanding of the routines, please see the Trixi.jl documentation.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The following code snippet sets up the discontinuous Galerkin spectral element method (DGSEM). In this solver type, we can specify which flux functions for the surface and volume fluxes will be taken, as well as the polynomial degree (polydeg) of the polynomials used in the approximation space.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"###############################################################################\n# Get the DG approximation space\n\nvolume_flux = (flux_wintermeyer_etal, flux_nonconservative_wintermeyer_etal)\nsolver = DGSEM(polydeg=3, surface_flux=(flux_hll, flux_nonconservative_fjordholm_etal),\n               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"After the solver comes the specification of the mesh in the approximation. In this case, a TreeMesh is chosen, which is a Cartesian mesh. Here the domain borders must be defined, as well as the number of initial elements (2 to the power of initial_refinement_level). Also, we have to indicate if the domain is periodic. In this example, boundary conditions were defined. Thus the periodicity is set to false.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"Once the underlying mesh is constructed, a semidiscretization object can be created by calling SemiDiscretizationHyperbolic. This collects all the building blocks needed to set up the semidiscretization:","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The underlying mesh.\nThe set of equations.\nThe initial condition.\nThe solver (in this case DGSEM).\nThe boundary conditions.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"###############################################################################\n# Get the TreeMesh and setup a periodic mesh\n\ncoordinates_min = spline_struct.x[1]\ncoordinates_max = spline_struct.x[end]\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level = 3,\n                n_cells_max = 10_000,\n                periodicity = false)\n\n# create the semi discretization object\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                    boundary_conditions = boundary_condition)","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"An ordinary differential equations object is set up using a specified time range, tspan, and the semidiscretization object, semi.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"###############################################################################\n# ODE solvers\n\ntspan = (0.0, 100.0)\node = semidiscretize(semi, tspan)\nnothing #hide","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The ordinary differential equations object ode is solved by the function sol which is part of the OrdinaryDiffEq.jl package. Here the time stepping method can be specified (in this case, RDPK3SpFSAL49()) as well as some tolerances responsible for an error-based time step control.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"###############################################################################\n# run the simulation\n\n# define equidistant nodes in time for visualization of an animation\nvisnodes = range(tspan[1], tspan[2], length = 90)\n\n# use a Runge-Kutta method with error-based time step size control\nsol = solve(ode, RDPK3SpFSAL49(), abstol = 1.0e-8, reltol = 1.0e-8,\n            saveat = visnodes)\nnothing #hide","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"At this point, the calculation is finished. However, to visualize the dam break problem, we want to create an animation of the solution to show its evolution over time. Above we created a uniform set of points in time visnodes and used the saveat attribute so that the solve saves solution information at these check-in values.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"We use the plotting backend CairoMakie.jl for this purpose. To create an animation we use the record structure to save plots over every time step of the simulation and append them together into an animation. Inside the loop, the PlotData1D functionality from Trixi.jl is called to create a plotting object. Afterwards, this plotting object is visualized using the lines command from Makie.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"Two Observable quantities are created, one to increment the number of plots and another for the time at which each solution occurs. The resulting animation is given below.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# Create animation of the solution\nj = Observable(1)\ntime = Observable(0.0)\n\npd_list = [PlotData1D(sol.u[i], semi) for i in 1:length(sol.t)]\nf = Figure()\ntitle_string = lift(t -> \"time t = $(round(t, digits=3))\", time)\nax = Axis(f[1, 1], xlabel = \"ETRS89 East\", ylabel = \"DHHN2016\",\n                title = title_string)\n\nheight = lift(i -> pd_list[i].data[:, 1], j)\nbottom = lift(i -> pd_list[i].data[:, 3], j)\nlines!(ax, pd_list[1].x, height)\nlines!(ax, pd_list[1].x, bottom)\nylims!(ax, 38, 65)\n\nrecord(f, \"animation.gif\", 1:length(pd_list)) do tt\n  j[] = tt\n  time[] = sol.t[tt]\nend\nnothing #hide","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"(Image: simTrixi1D)","category":"page"},{"location":"trixi_jl_examples/#Two-dimensional-dam-break","page":"Trixi.jl examples","title":"Two dimensional dam break","text":"","category":"section"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The underlying example file can be found here.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The two dimensional example is similar to the one dimensional case.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"First, all the necessary packages and the underlying bottom topography data are loaded.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# Include packages\nusing TrixiBottomTopography\nusing CairoMakie\nusing OrdinaryDiffEqLowStorageRK\nusing Trixi\n\nRhine_data = download(\"https://gist.githubusercontent.com/maxbertrand1996/a30db4dc9f5427c78160321d75a08166/raw/fa53ceb39ac82a6966cbb14e1220656cf7f97c1b/Rhine_data_2D_40.txt\")\nnothing #hide","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"Using the data, a bicubic B-spline interpolation is performed on the data to define a bottom topography function.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# B-spline interpolation of the underlying data.\n# The type of this struct is fixed as `BicubicBSpline`.\nconst spline_struct = BicubicBSpline(Rhine_data)\nspline_func(x::Float64, y::Float64) = spline_interpolation(spline_struct, x, y)","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"Then the two dimensional shallow water equations are defined, where the gravitational constant has been chosen to be 3.0 and the initial water height 55.0. Afterwards, the initial condition is defined. Similar to the one dimensional case, in the center of the domain, a circular part with a diameter of 100.0 is chosen where the initial water height is chosen to be 10.0 units higher.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"equations = ShallowWaterEquations2D(gravity_constant = 9.81, H0 = 55.0)\n\nfunction initial_condition_wave(x, t, equations::ShallowWaterEquations2D)\n\n  inicenter = SVector(357490.0, 5646519.0)\n  x_norm = x - inicenter\n  r = sqrt(x_norm[1]^2 + x_norm[2]^2)\n\n  # Calculate primitive variables\n  H =  r < 50 ? 65.0 : 55.0\n  v1 = 0.0\n  v2 = 0.0\n\n  x1, x2 = x\n  b = spline_func(x1, x2)\n\n  return prim2cons(SVector(H, v1, v2, b), equations)\nend\n\n# Setting initial condition\ninitial_condition = initial_condition_wave\n\n# Setting the boundary to be a free-slip wall\nboundary_condition = boundary_condition_slip_wall\nnothing #hide","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"This assigns the initial conditions and boundary conditions to appropriate names that can be passed to the forthcoming semidiscretization.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The DGSEM solver is set up as in the one dimensional case.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"###############################################################################\n# Get the DG approximation space\n\nvolume_flux = (flux_wintermeyer_etal, flux_nonconservative_wintermeyer_etal)\nsolver = DGSEM(polydeg=3, surface_flux=(flux_fjordholm_etal, flux_nonconservative_fjordholm_etal),\n               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"Now the mesh has to be specified. As above, we use a Cartesian box mesh created as a TreeMesh in Trixi.jl. Because we have defined boundary conditions defined, we set the periodicity to be false.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"###############################################################################\n# Get the TreeMesh and setup a periodic mesh\n\ncoordinates_min = (spline_struct.x[1], spline_struct.y[1])\ncoordinates_max = (spline_struct.x[end], spline_struct.y[end])\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level = 3,\n                n_cells_max = 10_000,\n                periodicity = false)","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"When calling the semidiscretization object again, boundary_conditions does not have to be specified.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"# create the semi discretization object\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                    boundary_conditions = boundary_condition)","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"The solution of the PDE and the animation is analogous to the one dimensional case except that we chose PlotData2D to create the plotting object instead of PlotData1D as we are in the two dimensional case now.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"As in the 1D example, we use the plotting backend CairoMakie.jl. To create an animation we use the record structure to save plots over every time step of the simulation and append them together into an animation. Inside the loop, the PlotData2D functionality from Trixi.jl is called to create a plotting object. Afterwards, this plotting object is visualized using the wireframe command to visualize the 2D water height evolution and surface to visualize bicubic B-spline approximation of the bottom topography. Two Observable quantities are created, one to increment the number of plots and another for the time at which each solution occurs. The the resulting animation is given below.","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"###############################################################################\n# ODE solvers, callbacks etc.\n\ntspan = (0.0, 100.0)\node = semidiscretize(semi, tspan)\n\n###############################################################################\n# run the simulation\n\n# define equidistant nodes in time for visualization of an animation\nvisnodes = range(tspan[1], tspan[2], length = 175)\n\n# use a Runge-Kutta method with error based time step size control\nsol = solve(ode, RDPK3SpFSAL49(), abstol = 1.0e-8, reltol = 1.0e-8,\n            saveat = visnodes);\n\n# Create an animation of the solution\nj = Observable(1)\ntime = Observable(0.0)\n\npd_list = [PlotData2D(sol.u[i], semi) for i in 1:length(sol.t)]\nf = Figure()\n\ntitle_string = lift(t ->  \"time t = $(round(t, digits=3))\", time)\naz = 130 * pi / 180\nel = 18 * pi / 180\nax = Axis3(f[1, 1], xlabel = \"E\", ylabel = \"N\", zlabel = \"H\",\n                  title = title_string, azimuth = az, elevation = el)\n\nheight = lift(i -> pd_list[i].data[1], j)\nbottom = lift(i -> pd_list[i].data[4], j)\nsurface!(ax, pd_list[1].x, pd_list[1].y, bottom;\n                colormap = :greenbrownterrain)\nwireframe!(ax, pd_list[1].x, pd_list[1].y, height;\n                  color = Makie.RGBA(0, 0.5, 1, 0.4))\nzlims!(ax, 35, 70)\n\nrecord(f, \"animation_2d.gif\", 1:length(pd_list)) do tt\n  j[] = tt\n  time[] = sol.t[tt]\nend\nnothing #hide","category":"page"},{"location":"trixi_jl_examples/","page":"Trixi.jl examples","title":"Trixi.jl examples","text":"(Image: simTrixi2D)","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2022-present Maximilian Dominique Bertrand and other contributors: AuthorsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"conversion/#Converting-DGM-data-files","page":"Data conversion","title":"Converting DGM data files","text":"","category":"section"},{"location":"conversion/#Introduction","page":"Data conversion","title":"Introduction","text":"","category":"section"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"Often geographical data is provided in the form of .xyz files. These files organized geographical data in three columns separated by [space] with an x, y and z component. For example:","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"1.0 1.0 1.0\n2.0 1.0 2.0\n3.0 1.0 3.0\n1.0 2.0 4.0\n2.0 2.0 5.0\n3.0 2.0 6.0\n1.0 3.0 7.0\n2.0 3.0 8.0\n3.0 3.0 9.0","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"In the example above, we have 1.0, 2.0, 3.0 as possible x and y coordinate values. Such .xyz formatted files provide the corresponding z value for all possible x-y combinations. In this case, for example, at [2.0, 3.0], the corresponding z value is 6.0.","category":"page"},{"location":"conversion/#DGM-data-set","page":"Data conversion","title":"DGM data set","text":"","category":"section"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"In the examples folder of this repo, the underlying data has been received from Geobasis NRW. They provide a geographical data set of the German state of North Rhine-Westphalia called DGM. This data set contains patches of 1km^2 where each patch has the elevation data for 1000000 data points equally distributed as a grid with a grid size of 1m. As an example, the data can be given as .xyz files:","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"357000.00 5646999.00 47.40\n357001.00 5646999.00 47.43\n357002.00 5646999.00 47.49\n357003.00 5646999.00 47.47\n357004.00 5646999.00 47.39\n357005.00 5646999.00 47.30\n357006.00 5646999.00 47.24\n...       ...        ...","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"where the first column provides the corresponding ETRS89 East coordinates, the second column the ETRS89 North coordinates and the third column the DHHN2016 height.","category":"page"},{"location":"conversion/#Data-format-of-TrixiBottomTopography.jl","page":"Data conversion","title":"Data format of TrixiBottomTopography.jl","text":"","category":"section"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"The provided .xyz files of DGM are not directly accepted by TrixiBottomTopography.jl to define B-spline interpolation structures. To make the raw topography data work with the package, it must be converted into .txt files and organized in a specific format.","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"For one dimensional interpolation, TrixiBottomTopography.jl requires the following form:","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"# Number of x values\nn\n# x values\nx_1\n...\nx_n\n# y values\ny_1\n...\ny_n","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"and to interpolate two dimensional data:","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"# Number of x values\nn\n# Number of y values\nm\n# x values\nx_1\n...\nx_n\n# y values\ny_1\n...\ny_m\n# z values\nz_1,1\nz_1,2\n...\nz_1,n\nz_2,1\n...\nz_m,n","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"The x, y and z values must be set to Float64 format.","category":"page"},{"location":"conversion/#Conversion-functions","page":"Data conversion","title":"Conversion functions","text":"","category":"section"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"To make matters easier, TrixiBottomTopography.jl provides the functions convert_dgm_1d for one dimensional interpolation and convert_dgm_2d for two dimensional interpolation.","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"To explain these functions, we consider the example file convert_data.jl.","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"First, we import our package to be able to use the functions.","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"# Include packages\nusing TrixiBottomTopography\nusing Downloads: download","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"Next, we define the path of the .xyz file path_src_file that we want to convert, as well as the paths of the files where we want to save them files.","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"# Define file paths\nroot_dir = pkgdir(TrixiBottomTopography)\n\n# Download the raw bottom topography data\npath_src_file = download(\"https://gist.githubusercontent.com/maxbertrand1996/c6917dcf80aef1704c633ec643a531d5/raw/f09b43f604adf9e2cfb45a7d998418f1e72f251d/dgm1_32_357_5646_1_nw.xyz\",\n                         joinpath(root_dir, \"examples\", \"data\", \"dgm1_32_357_5646_1_nw.xyz\"))\n\npath_src_file = joinpath(root_dir, \"examples\", \"data\", \"dgm1_32_357_5646_1_nw.xyz\")\npath_out_file_1d_x = joinpath(root_dir, \"examples\", \"data\", \"rhine_data_1d_20_x.txt\")\npath_out_file_1d_y = joinpath(root_dir, \"examples\", \"data\", \"rhine_data_1d_20_y.txt\")\npath_out_file_2d = joinpath(root_dir, \"examples\", \"data\", \"rhine_data_2d_20.txt\")\nnothing #hide","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"The source data from path_src_file looks as follows:","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"357000.00 5646999.00 47.40\n357001.00 5646999.00 47.43\n357002.00 5646999.00 47.49\n357003.00 5646999.00 47.47\n357004.00 5646999.00 47.39\n357005.00 5646999.00 47.30\n357006.00 5646999.00 47.24\n...       ...        ...","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"Here, you can see the entire file.","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"Now the data can be converted.","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"# Convert data\nconvert_dgm_1d(path_src_file, path_out_file_1d_x; excerpt = 20, section = 100);","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"Calling this expression tells convert_dgm_1d that the source file is path_src_file and the converted file will be saved in the file path_out_file_1d_x. The optional attribute excerpt tells the function that only every 20th point in the x direction (in this case, in the ETRS89 East coordinate) will be considered. Setting section to 100 tells the function that the corresponding z values (DHHN2016 in this case) from the 100th y coordinate (ETRS89 North) will be chosen. The entire converted file produced by this routine is available here.","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"convert_dgm_1d(path_src_file, path_out_file_1d_y; excerpt = 20, direction = \"y\", section = 100);","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"Similar to the previous expression, this one has the additional attribute direction = \"y\" which tells convert_dgm_1d that the data will be read from the y direction. (Click here to view the resulting file)","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"convert_dgm_2d(path_src_file, path_out_file_2d; excerpt = 20);","category":"page"},{"location":"conversion/","page":"Data conversion","title":"Data conversion","text":"The two dimensional version convert_dgm_2d works similar to the one dimensional case except that the optional attributes direction and section do not exist, but only excerpt. Setting e.g. to 20 tells the function that only every 20th value in the x and y direction of the source file path_src_file will be stored in path_out_file_2d. The resulting file after the two dimensional conversion is available here.","category":"page"},{"location":"styleguide/#Style-guide","page":"Style guide","title":"Style guide","text":"","category":"section"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"Coding style is an inherently personal - and thus hotly contested - issue. Since code is usually \"written once, read often\", it helps regular developers, new users, and reviewers if code is formatted consistently. We therefore believe in the merit of using a common coding style throughout TrixiBottomTopography.jl, even at the expense that not everyone can be happy with every detailed style decision. If you came here because you are furious about our code formatting rules, here is a happy little whale for you to calm you down: 🐳","category":"page"},{"location":"styleguide/#Conventions","page":"Style guide","title":"Conventions","text":"","category":"section"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"The following lists a few coding conventions for TrixiBottomTopography.jl. Note that in addition to these conventions, we apply and enforce automated source code formatting (see below for more details):","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"Modules, types, structs with CamelCase.\nFunctions, variables with lowercase snake_case.\nIndentation with 4 spaces (never tabs!)\nMaximum line length (strictly): 92.\nFunctions that mutate their input are named with a trailing !.\nFunctions order their parameters similar to Julia Base.\nThe main modified argument comes first. For example, if the right-hand side du is modified, it should come first. If only the cache is modified, e.g., in prolong2interfaces! and its siblings, put the cache first.\nOtherwise, use the order mesh, equations, solver, cache.\nIf something needs to be specified in more detail for dispatch, put the additional argument before the general one that is specified in more detail. For example, we use have_nonconservative_terms(equations), equations and dg.mortar, dg.\nPrefer for i in ... to for i = ... for better semantic clarity and greater flexibility.\nExecutable code should only use ASCII characters.\nDocstrings and comments can and should use Unicode characters where it helps understanding.\nMultiline expressions should be explicitly grouped by parentheses and not rely on Julia's implicit line continuation syntax.\nWhen naming multiple functions of a single or similar category, prefer to put the general classification first and the specialization second. Example: Use flux_central instead of central_flux. This helps when searching for available functions on the REPL (e.g., when trying to find all flux functions).","category":"page"},{"location":"styleguide/#automated-source-code-formatting","page":"Style guide","title":"Automated source code formatting","text":"","category":"section"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"We use JuliaFormatter.jl to format the source code of TrixiBottomTopography.jl, which will also enforce some of the Conventions listed above (e.g., line length or indentation with 4 spaces are automatically handled, while capitalization of names is not). Our format is mostly based on the SciML-style formatting rules. For more details you can have a look at the current .JuliaFormatter.toml file that holds the configuration options we use for JuliaFormatter.jl.","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"Note that we expect all contributions to TrixiBottomTopography.jl to be formatted with JuliaFormatter.jl before being merged to the main branch. We ensure this by running a automated check on all PRs that verify that running JuliaFormatter.jl again will not change the source code.","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"To format your contributions before created a PR (or, at least, before requesting a review of your PR), you need to install JuliaFormatter.jl first by running","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"julia -e 'using Pkg; Pkg.add(PackageSpec(name = \"JuliaFormatter\", version=\"1.0.60\"))'","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"You can then recursively format the core Julia files in the TrixiBottomTopography.jl repo by executing","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"julia -e 'using JuliaFormatter; format(\".\")'","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"from inside the TrixiBottomTopography.jl repository. For convenience, there is also a script you can directly run from your terminal shell, which will automatically install JuliaFormatter in a temporary environment and then run it:","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"utils/trixibt-format.jl","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"You can get more information about using the convenience script by running it with the --help/-h flag. There is an additional script to format individual files that can be run from the terminal shell","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"utils/trixibt-format-file.jl path/to/file.jl","category":"page"},{"location":"styleguide/#Checking-formatting-before-committing","page":"Style guide","title":"Checking formatting before committing","text":"","category":"section"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"It can be convenient to check the formatting of source code automatically before each commit. We use git-hooks for it and provide a pre-commit script in the utils folder. The script uses JuliaFormatter.jl just like formatting script that runs over the whole TrixiBottomTopography.jl directory. You can copy the pre-commit-script into .git/hooks/pre-commit and it will check your formatting before each commit. If errors are found the commit is aborted and you can add the corrections via","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"git add -p","category":"page"},{"location":"structure/#B-spline-interpolation-structure","page":"B-spline structure","title":"B-spline interpolation structure","text":"","category":"section"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Once the underlying data is in the correct format, we can start defining B-spline structures which we will use later to define the interpolation functions.","category":"page"},{"location":"structure/#One-dimensional-structures","page":"B-spline structure","title":"One dimensional structures","text":"","category":"section"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"For the one dimensional case, the structures LinearBSpline and CubicBSpline are available. They contain all relevant values to define linear and cubic B-spline interpolation functions corresponding to linear and cubic B-spline interpolation. These are:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"x: A vector of values in x-direction.\nDelta: The length of a single patch in the given data set. A patch is the area between two consecutive          x values. Delta corresponds to the distance between two consecutive values in x-direction.          As we are only considering Cartesian grids, Delta is equal for all patches.\nQ: A vector that contains the control points.\nIP: The coefficients matrix.","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"To populate the structure, the outer constructor functions LinearBSpline(data_path) and CubicBSpline(data_path) are implemented. These constructors use the files in data_path to obtain the values which will be stored in the corresponding structure, as well as LinearBSpline(x,y) and CubicBSpline(x,y) which use given vectors x and y.","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"To get a better idea of the constructor functions, we consider the example rhine_data_cubic-nak.jl from the examples folder of this repo. This particular example reads one dimensional bottom topography data from a .txt file and constructs a cubic B-spline interpolation with not-a-knot end condition and smoothing of the data.","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"# Include packages\nusing TrixiBottomTopography\n\n# Define data path\nroot_dir = pkgdir(TrixiBottomTopography)\ndata = joinpath(root_dir, \"examples\", \"data\", \"rhine_data_1d_20_x.txt\")\n\n# Define B-spline structure\nspline_struct = CubicBSpline(data; end_condition = \"not-a-knot\", smoothing_factor = 999)","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"For the cubic case, we can also set the optional parameters end_condition, which defines (as the name suggests) the end condition of the spline. Available end conditions are the not-a-knot and the free end condition. By default, end_condition is set to free. If you are not familiar with the differences and influence of these end conditions, see Chapter 1 of","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Quentin Agrapart & Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. hal-03017566v2.","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Besides the end condition, we can also specify a smoothing_factor for the cubic B-spline. This smoothing parameter defines a trade-off for the resulting cubic B-spline interpolation between how well the B-spline models (or fits) the original data and minimizing the curvature by defining new y values. This procedure is called spline smoothing. There is no general approach to determine which smoothing_factor is best suited for a given problem. It must be determined by the user via trial and error. However, as a general rule, the larger the smoothing factor, the less curvature will be present in the resulting B-spline. To understand the underlying maths of the smoothing spline procedure, please see:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Germán Rodríguez (2001), Smoothing and non-parametric regression","category":"page"},{"location":"structure/#Two-dimensional-structures","page":"B-spline structure","title":"Two dimensional structures","text":"","category":"section"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"For the two dimensional case, the structures BilinearBSpline and BicubicBSpline are implemented, which contain all relevant values to define bilinear and bicubic B-spline interpolation functions. These are:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"x: Vector of values in x-direction.\ny: Vector of values in y-direction.\nDelta: Length of one side of a single patch in the given data set. A patch is the area between two consecutive x and y values. Delta corresponds to the distance between two consecutive values in x-direction. The implementation only considers Cartesian grids, so Delta is equal for all patches in x and y-direction.\nQ: Matrix which contains the control points.\nIP: Coefficients matrix.","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"To populate the structure, the outer constructor functions BilinearBSpline(data_path) and BicubicBSpline(data_path) are implemented. They use the files in data_path to obtain the values which will be stored in the corresponding structure. Further, BilinearBSpline(x,y,z) and BicubicBSpline(x,y,z) which use given vectors x and y and matrix z. The x, y and z data are organized in the following form:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"beginaligned\nbeginmatrix\n      x_1  x_2    x_n\n        \n    y_1   z_11  z_12    z_1n\n    y_1   z_21  z_22    z_2n\n    vdots   vdots  vdots  ddots  vdots\n    y_m   z_m1  z_m2    z_mn\n  endmatrix\nendaligned","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"To better understand the constructor functions, we consider the example rhine_data_bicubic-nak.jl of this repo. This example reads in two dimensional bottom topography data from a .txt file and creates a bicubic B-spline interpolation with not-a-knot end condition and smoothing of the data.","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"# Include packages\nusing TrixiBottomTopography\n\n# Define data path\nroot_dir = pkgdir(TrixiBottomTopography)\ndata = joinpath(root_dir, \"examples\", \"data\", \"rhine_data_2d_20.txt\")\n\n# Define B-spline structure\nspline_struct = BicubicBSpline(data; end_condition = \"not-a-knot\", smoothing_factor = 9999)","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"For the bicubic spline, we can set the optional parameters end_condition, which defines (as in the one dimensional case) the end condition of the spline. Again, the available end conditions are the not-a-knot and the free end condition. By default, end_condition is set to free. If you are not familiar with the differences and influence of these end conditions, see Chapter 2 of","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Quentin Agrapart & Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. hal-03017566v2","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Besides the end condition, we can also specify a smoothing_factor for the bicubic spline. Just as in the one dimensional constructor, this smoothing provides a trade-off of the bicubic B-spline interpolation between how well it models (or fits) the original topography data and minimizing the curvature of the spline by defining new z values. This procedure is called thin plate spline. There is no general approach to which smoothing_factor is best suited for the problem, and it must be determined via trial and error by the user. To understand the underlying maths of the thin plate spline, please see:","category":"page"},{"location":"structure/","page":"B-spline structure","title":"B-spline structure","text":"Gianluca Donato and Serge Belongie (2001), Approximate Thin Plate Spline Mappings DOI: 10.1007/3-540-47977-5_2","category":"page"},{"location":"#TrixiBottomTopography.jl","page":"Home","title":"TrixiBottomTopography.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Docs-stable) (Image: Docs-dev) (Image: Build Status) (Image: Coverage Status) (Image: License: MIT) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl is a supplementary package to the numerical solvers Trixi.jl and TrixiShallowWater.jl, which enables use of real world geographical data for the bottom topography function of the shallow water equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The shallow water equations in one dimension","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nbeginpmatrix h  hv endpmatrix_t\n+ beginpmatrix hv  hv^2 + frac12gh^2 endpmatrix_x\n= beginpmatrix 0 -ghb_x endpmatrix\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"and two dimensions","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nbeginpmatrix h  hv_1  hv_2 endpmatrix_t\n+ beginpmatrix hv_1  hv_1^2 + frac12gh^2  hv_1v_2 endpmatrix_x\n+ beginpmatrix hv_2  hv_1v_2  hv_2^2 + frac12gh^2  endpmatrix_y\n= beginpmatrix 0 -ghb_x  -ghb_y endpmatrix\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"require a (piecewise) differentiable function b, which describes the bottom topography.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Geographical data is almost always given as scattered data points on a coordinate system with the corresponding elevation. So to incorporate geographical data into the shallow water equations, we need to define a function that remodels the topography from the data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl does this by B-spline interpolation of the underlying data.","category":"page"},{"location":"#Functionalities","page":"Home","title":"Functionalities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains the following three main functionalities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Converting geographical data given in form of .xyz files, e.g., from the DGM data set provided by Geobasis NRW to make it readable for TrixiBottomTopography.jl\nSetting up a B-spline interpolation structure in one and two dimensions which contains all the relevant information to define a B-spline interpolation function with additional specifications\nUsing the B-spline structure to set up a B-spline interpolation function","category":"page"},{"location":"","page":"Home","title":"Home","text":"A detailed description of the functionalities can be found in the documentation to this package.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not yet installed Julia, please follow the instructions for your operating system. TrixiBottomTopography.jl works with Julia v1.10 and newer. We recommend using the latest stable release of Julia.","category":"page"},{"location":"#For-users","page":"Home","title":"For users","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl and its related tools are registered Julia packages. Hence, you can install it by executing the following commands in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"TrixiBottomTopography\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The available visualization functionality uses Makie.jl. A Makie backend, such as GLMakie.jl, can be installed in addition to TrixiBottomTopography","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"GLMakie\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use TrixiBottomTopography.jl together with the numerical solver framework Trixi.jl, you need both Trixi.jl and a relevant time integration sub-package of OrdinaryDiffEq.jl, e.g., for high-order low-storage Runge-Kutta schemes. These can be added by executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add([\"Trixi\", \"OrdinaryDiffEqLowStorageRK\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl can also be used together with TrixiShallowWater.jl, a solver suite specifically designed for shallow water flow applications. An example that combines TrixiBottomTopography.jl with wet/dry transitions and shock capturing to model a tsunami runup is available as a tutorial in TrixiShallowWater.jl.","category":"page"},{"location":"#For-developers","page":"Home","title":"For developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you plan on editing TrixiBottomTopography.jl itself, you can download TrixiBottomTopography.jl locally and use the code from the cloned directory:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone git@github.com:trixi-framework/TrixiBottomTopography.jl.git\ncd TrixiBottomTopography.jl\nmkdir run\ncd run\njulia --project=. -e 'using Pkg; Pkg.develop(PackageSpec(path=\"..\"))' # Install local TrixiBottomTopography.jl clone\njulia --project=. -e 'using Pkg; Pkg.add([\"GLMakie\", \"Trixi\", \"OrdinaryDiffEqLowStorageRK\"])' # Install additional packages","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the additional packages are optional and can be omitted.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you installed TrixiBottomTopography.jl this way, you always have to start Julia with the --project flag set to your run directory, e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=.","category":"page"},{"location":"","page":"Home","title":"Home","text":"if already inside the run directory or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=run","category":"page"},{"location":"","page":"Home","title":"Home","text":"if inside the repository root directory.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To see a first example of TrixiBottomTopography.jl a default example has been implemented. First, load the packages and either of the backends GLMakie.jl or CairoMakie.jl to activate the visualization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TrixiBottomTopography, GLMakie","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then call the default_example for TrixiBottomTopography.jl as","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> TrixiBottomTopography.default_example()","category":"page"},{"location":"","page":"Home","title":"Home","text":"If the implementation was successful, the following window appears:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further examples can be found in the examples folder of this repository.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl was developed by Maximilian Dominique Bertrand (University of Cologne, Germany) with the help of Andrew Winters (Linköping University, Sweden) and Michael Schlottke-Lakemper (RWTH Aachen University, Germany). The full list of contributors can be found in Authors.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TrixiBottomTopography.jl is published under the MIT license (see License). We are pleased to accept contributions from everyone, preferably in the form of a PR.","category":"page"}]
}
