<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · TrixiBottomTopography.jl</title><meta name="title" content="Reference · TrixiBottomTopography.jl"/><meta property="og:title" content="Reference · TrixiBottomTopography.jl"/><meta property="twitter:title" content="Reference · TrixiBottomTopography.jl"/><meta name="description" content="Documentation for TrixiBottomTopography.jl."/><meta property="og:description" content="Documentation for TrixiBottomTopography.jl."/><meta property="twitter:description" content="Documentation for TrixiBottomTopography.jl."/><meta property="og:url" content="https://trixi-framework.github.io/TrixiBottomTopography.jl/stable/reference/"/><meta property="twitter:url" content="https://trixi-framework.github.io/TrixiBottomTopography.jl/stable/reference/"/><link rel="canonical" href="https://trixi-framework.github.io/TrixiBottomTopography.jl/stable/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TrixiBottomTopography.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Overview</span><ul><li><a class="tocitem" href="../conversion/">Data conversion</a></li><li><a class="tocitem" href="../structure/">B-spline structure</a></li><li><a class="tocitem" href="../function/">B-spline function</a></li></ul></li><li><a class="tocitem" href="../trixi_jl_examples/">Trixi.jl examples</a></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../development/">Development</a></li><li><a class="tocitem" href="../styleguide/">Style guide</a></li><li><a class="tocitem" href="../testing/">Testing</a></li></ul></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../license/">License</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/trixi-framework/TrixiBottomTopography.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TrixiBottomTopography.jl-API"><a class="docs-heading-anchor" href="#TrixiBottomTopography.jl-API">TrixiBottomTopography.jl API</a><a id="TrixiBottomTopography.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#TrixiBottomTopography.jl-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.TrixiBottomTopography" href="#TrixiBottomTopography.TrixiBottomTopography"><code>TrixiBottomTopography.TrixiBottomTopography</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TrixiBottomTopography</code></pre><p><strong>TrixiBottomTopography.jl</strong> is a supporting framework for Trixi.jl and TrixiShallowWater.jl, which can be used to approximate bottom topography functions using B-splines from real world data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/TrixiBottomTopography.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.BicubicBSpline" href="#TrixiBottomTopography.BicubicBSpline"><code>TrixiBottomTopography.BicubicBSpline</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BicubicBSpline(x, y, Delta, Q, IP)</code></pre><p>Two dimensional cubic B-spline structure that contains all important attributes to define a B-Spline interpolation function. These attributes are:</p><ul><li><code>x</code>: Vector of values in x-direction</li><li><code>y</code>: Vector of values in y-direction</li><li><code>Delta</code>: Length of one side of a single patch in the given data set. A patch is the area between          two consecutive <code>x</code> and <code>y</code> values. The value <code>Delta</code> corresponds to the distance between          two consecutive values in x-direction. As we are only considering Cartesian grids,          <code>Delta</code> is equal for all patches in x and y-direction</li><li><code>Q</code>: Matrix which contains the control points</li><li><code>IP</code>: Coefficients matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_cache_2D.jl#L154-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.BicubicBSpline-Tuple{String}" href="#TrixiBottomTopography.BicubicBSpline-Tuple{String}"><code>TrixiBottomTopography.BicubicBSpline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BicubicBSpline(path::String; end_condition = &quot;free&quot;, smoothing_factor = 0.0)</code></pre><p>A function which reads in the <code>x</code>, <code>y</code> and <code>z</code> values for <a href="#TrixiBottomTopography.BilinearBSpline"><code>BilinearBSpline</code></a> from a .txt file. The input values are:</p><ul><li><code>path</code>: String of a path of the specific .txt file</li><li><code>end_condition</code>: String which can either be &quot;free&quot; or &quot;not-a-knot&quot; and defines which                  end condition should be considered.                  By default this is set to &quot;free&quot;</li><li><code>smoothing_factor</code>: Float64 <span>$\geq$</span> 0.0 which specifies the degree of smoothing of the <code>y</code> values.                     By default this value is set to 0.0 which corresponds to no smoothing.</li></ul><p>The .txt file has to have the following structure to be interpreted by this function:</p><ul><li>First line: comment <code># Number of x values</code></li><li>Second line: integer which gives the number of <code>x</code> values</li><li>Third line: comment <code># Number of y values</code></li><li>Fourth line: integer which gives the number of <code>y</code> values</li><li>Fifth line: comment <code># x values</code></li><li>Following lines: the <code>x</code> values where each value has its own line</li><li>Line after the x-values: comment <code># y values</code></li><li>Following lines: <code>y</code> values where each value has its own line</li><li>Line after the y-values: comment <code># z values</code></li><li>Remaining lines: values for <code>z</code> where each value has its own line and is in th following order:                  z<em>11, z</em>12, ... z<em>1n, z</em>21, ... z<em>2n, ..., z</em>m1, ..., z_mn</li></ul><p>An example can be found <a href="https://gist.githubusercontent.com/maxbertrand1996/7b1b943eac142d5bc836bb818fe83a5a/raw/74228e349e91fbfe1563479f99943b469f26ac62/Rhine_data_2D_10.txt">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_cache_2D.jl#L541-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.BicubicBSpline-Tuple{Vector, Vector, Matrix}" href="#TrixiBottomTopography.BicubicBSpline-Tuple{Vector, Vector, Matrix}"><code>TrixiBottomTopography.BicubicBSpline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BicubicBSpline(x::Vector, y::Vector, z::Matrix; end_condition = &quot;free&quot;, smoothing_factor = 0.0)</code></pre><p>This function calculates the inputs for the structure <a href="#TrixiBottomTopography.BicubicBSpline"><code>BicubicBSpline</code></a>. The input values are:</p><ul><li><code>x</code>: Vector that contains equally spaced values in x-direction</li><li><code>y</code>: Vector that contains equally spaced values in y-direction where the spacing between the      y-values has to be the same as the spacing between the x-values</li><li><code>z</code>: Matrix that contains the corresponding values in z-direction.      Where the values are ordered in the following way:</li></ul><p class="math-container">\[\begin{aligned}
    \begin{matrix}
        &amp; &amp; x_1 &amp; x_2 &amp; ... &amp; x_n\\
        &amp; &amp; &amp; &amp; &amp;\\
        y_1 &amp; &amp; z_{11} &amp; z_{12} &amp; ... &amp; z_{1n}\\
        y_1 &amp; &amp; z_{21} &amp; z_{22} &amp; ... &amp; z_{2n}\\
        \vdots &amp; &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
        y_m &amp; &amp; z_{m1} &amp; z_{m2} &amp; ... &amp; z_{mn}
    \end{matrix}
\end{aligned}\]</p><ul><li><code>end_condition</code>: a string which can either be &quot;free&quot; or &quot;not-a-knot&quot; and defines which                  end condition should be considered. By default this is set to &quot;free&quot;.</li><li><code>smoothing_factor</code>: a Float64 <span>$\geq$</span> 0.0 which specifies the degree of smoothing of the <code>z</code>                     values. By default this value is set to 0.0 which corresponds to no                     smoothing.</li></ul><p>Bicubic B-spline interpolation is only possible if the dimensions of vectors <code>x</code> and <code>y</code> correspond with the dimensions of the matrix <code>z</code>.</p><p>First, the data is sorted via <a href="#TrixiBottomTopography.sort_data-Tuple{Vector, Vector, Matrix}"><code>sort_data</code></a> to guarantee that the <code>x</code> and <code>y</code> values are in ascending order with corresponding matrix <code>z</code>.</p><p>The patch size <code>Delta</code> is calculated by subtracting the second by the first <code>x</code> value. This can be done because we only consider equal space between consecutive <code>x</code> and <code>y</code> values. A patch is the area between two consecutive <code>x</code> and <code>y</code> values.</p><p>If a <code>smoothing_factor</code> <span>$&gt;$</span> 0.0 is set, the function <a href="#TrixiBottomTopography.calc_tps-Tuple{Number, Vector, Vector, Matrix}"><code>calc_tps</code></a> calculates new values for <code>z</code> which guarantee a resulting parametric B-spline surface with less curvature.</p><p>The coefficients matrix <code>IP</code> for bicubic B-splines is fixed to be</p><p class="math-container">\[\begin{aligned}
    \begin{pmatrix}
        -1 &amp; 3 &amp; -3 &amp; 1\\
        3 &amp; -6 &amp; 3 &amp; 0\\
        -3 &amp; 0 &amp; 3 &amp; 0\\
        1 &amp; 4 &amp; 1 &amp; 0
    \end{pmatrix}
\end{aligned}\]</p><p>To get the matrix of control points <code>Q</code> which is necessary to set up an interpolation function, we need to define a matrix <code>Phi</code> which maps the control points to a vector <code>P</code>. This can be done by solving the following system of linear equations for <code>Q</code>.</p><p class="math-container">\[\underbrace{
    \begin{bmatrix}
        z_{1,1} \\ z_{1,2} \\ \vdots \\ z_{1,n} \\ z_{2,1} \\ \vdots \\ z_{m,n} \\ 0 \\ \vdots \\ 0
    \end{bmatrix}
    }_{\text{:=P} \in \mathbb{R}^{(m+2)(n+2)\times 1}} = \frac{1}{36}
    \Phi \cdot
    \underbrace{\begin{bmatrix}
        Q_{1,1} \\ Q_{1,2} \\ \vdots \\ Q_{1,n+2} \\ Q_{2,1} \\ \vdots \\ Q_{m+2,n+2}
    \end{bmatrix}}_{\text{:= Q} \in \mathbb{R}^{(m+2) \times (n+2)}}\]</p><p>For the first <code>n</code> <span>$\cdot$</span> <code>m</code> lines, the matrix <code>Phi</code> is the same for the &quot;free&quot; end and the &quot;not-a-knot&quot; end condition. These lines have to address the following condition:</p><p class="math-container">\[\begin{align*}
    z_{j,i} = \frac{1}{36} \Big( &amp;Q_{j,i} + 4Q_{j+1,i} + Q_{j+2,i} + 4Q_{j,i+1} + 16Q_{j+1,i+1}\\
    &amp;+ 4Q_{j+2,i+1} + Q_{j,i+2} + 4Q_{j+1,i+2} + Q_{j+2,i+2} \Big)
\end{align*}\]</p><p>for i = 1,...,n and j = 1,...,m.</p><p>The &quot;free&quot; end condition needs at least two values for the <code>x</code> and <code>y</code> vectors. The &quot;free&quot; end condition has the following additional requirements for the control points which have to be addressed by <code>Phi</code>:</p><ul><li><span>$Q_{j,1} - 2Q_{j,2} + Q_{j,3} = 0$</span> for j = 2,...,m+1</li><li><span>$Q_{j,n} - 2Q_{j,n+1} + Q_{j,n+2} = 0$</span> for j = 2,...,m+1</li><li><span>$Q_{1,i} - 2Q_{2,i} + Q_{3,i} = 0$</span> for i = 2,...,n+1</li><li><span>$Q_{m,i} - 2Q_{m+1,i} + Q_{m+2,i} = 0$</span> for i = 2,...,n+1</li><li><span>$Q_{1,1} - 2Q_{2,2} + Q_{3,3} = 0$</span></li><li><span>$Q_{m+2,1} - 2Q_{m+1,2} + Q_{m,3} = 0$</span></li><li><span>$Q_{1,n+2} - 2Q_{2,n+1} + Q_{3,n} = 0$</span></li><li><span>$Q_{m,n} - 2Q_{m+1,n+1} + Q_{m+2,n+2} = 0$</span></li></ul><p>The &quot;not-a-knot&quot; end condition needs at least four values for the <code>x</code> and <code>y</code> vectors.</p><ul><li>Continuity of the third <code>x</code> derivative between the leftmost and second leftmost patch</li><li>Continuity of the third <code>x</code> derivative between the rightmost and second rightmost patch</li><li>Continuity of the third <code>y</code> derivative between the patch at the top and the patch below</li><li>Continuity of the third <code>y</code> derivative between the patch at the bottom and the patch above</li><li><span>$Q_{1,1} - Q_{1,2} - Q_{2,1} + Q_{2,2} = 0$</span></li><li><span>$Q_{m-1,1} + Q_{m,1} + Q_{m-1,2} - Q_{m,2} = 0$</span></li><li><span>$Q_{1,n-1} + Q_{2,n} + Q_{1,n-1} - Q_{2,n} = 0$</span></li><li><span>$Q_{m-1,n-1} - Q_{m,n-1} - Q_{m-1,n} + Q_{m,n} = 0$</span></li></ul><p>A reference for the calculations in this script can be found in Chapter 2 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_cache_2D.jl#L178-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.BilinearBSpline" href="#TrixiBottomTopography.BilinearBSpline"><code>TrixiBottomTopography.BilinearBSpline</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BilinearBSpline(x, y, Delta, Q, IP)</code></pre><p>Two dimensional bilinear B-spline structure that contains all important attributes to define a B-Spline interpolation function. These attributes are:</p><ul><li><code>x</code>: Vector of values in x-direction</li><li><code>y</code>: Vector of values in y-direction</li><li><code>Delta</code>: Length of one side of a single patch in the given data set. A patch is the area between          two consecutive <code>x</code> and <code>y</code> values. The value <code>Delta</code> corresponds to the distance          between two consecutive values in x-direction. As we are only considering Cartesian          grids, <code>Delta</code> is equal for all patches in x and y-direction</li><li><code>Q</code>: Matrix which contains the control points</li><li><code>IP</code>: Coefficients matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_cache_2D.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.BilinearBSpline-Tuple{String}" href="#TrixiBottomTopography.BilinearBSpline-Tuple{String}"><code>TrixiBottomTopography.BilinearBSpline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BilinearBSpline(path::String)</code></pre><p>A function which reads in the <code>x</code>, <code>y</code> and <code>z</code> values for <a href="#TrixiBottomTopography.BilinearBSpline"><code>BilinearBSpline</code></a> from a .txt file. The input values are:</p><ul><li><code>path</code>: String of a path of the specific .txt file</li></ul><p>The .txt file has to have the following structure to be interpreted by this function:</p><ul><li>First line: comment <code># Number of x values</code></li><li>Second line: integer which gives the number of <code>x</code> values</li><li>Third line: comment <code># Number of y values</code></li><li>Fourth line: integer which gives the number of <code>y</code> values</li><li>Fifth line: comment <code># x values</code></li><li>Following lines: the <code>x</code> values where each value has its own line</li><li>Line after the x-values: comment <code># y values</code></li><li>Following lines: <code>y</code> values where each value has its own line</li><li>Line after the y-values: comment <code># z values</code></li><li>Remaining lines: values for <code>z</code> where each value has its own line and is in the following order:                  z<em>11, z</em>12, ... z<em>1n, z</em>21, ... z<em>2n, ..., z</em>m1, ..., z_mn</li></ul><p>An example can be found <a href="https://gist.githubusercontent.com/maxbertrand1996/7b1b943eac142d5bc836bb818fe83a5a/raw/74228e349e91fbfe1563479f99943b469f26ac62/Rhine_data_2D_10.txt">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_cache_2D.jl#L109-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.BilinearBSpline-Tuple{Vector, Vector, Matrix}" href="#TrixiBottomTopography.BilinearBSpline-Tuple{Vector, Vector, Matrix}"><code>TrixiBottomTopography.BilinearBSpline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BilinearBSpline(x::Vector, y::Vector, z::Matrix)</code></pre><p>This function calculates the inputs for the structure <a href="#TrixiBottomTopography.BilinearBSpline"><code>BilinearBSpline</code></a>. The input values are:</p><ul><li><code>x</code>: Vector that contains equally spaced values in x-direction</li><li><code>y</code>: Vector that contains equally spaced values in y-direction where the spacing between the      y-values has to be the same as the spacing between the x-values</li><li><code>z</code>: Matrix that contains the corresponding values in z-direction.      Where the values are ordered in the following way:</li></ul><p class="math-container">\[\begin{aligned}
   \begin{matrix}
        &amp; &amp; x_1 &amp; x_2 &amp; ... &amp; x_n\\
        &amp; &amp; &amp; &amp; &amp;\\
        y_1 &amp; &amp; z_{11} &amp; z_{12} &amp; ... &amp; z_{1n}\\
        y_1 &amp; &amp; z_{21} &amp; z_{22} &amp; ... &amp; z_{2n}\\
        \vdots &amp; &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
        y_m &amp; &amp; z_{m1} &amp; z_{m2} &amp; ... &amp; z_{mn}
   \end{matrix}
\end{aligned}\]</p><p>Bilinear B-spline interpolation is only possible if we have at least two values in <code>x</code> and two values in <code>y</code> and the dimensions of vectors <code>x</code> and <code>y</code> correspond with the dimensions of the matrix <code>z</code>.</p><p>First of all the data is sorted which is done by <a href="#TrixiBottomTopography.sort_data-Tuple{Vector, Vector, Matrix}"><code>sort_data</code></a> to guarantee that the <code>x</code> and <code>y</code> values are in ascending order with corresponding matrix <code>z</code>.</p><p>The patch size <code>Delta</code> is calculated by subtracting the second by the first <code>x</code> value. This can be done because we only consider equal space between consecutive <code>x</code> and <code>y</code> values. A patch is the area between two consecutive <code>x</code> and <code>y</code> values.</p><p>For bilinear B-spline interpolation, the control points <code>Q</code> correspond with the <code>z</code> values.</p><p>The coefficients matrix <code>IP</code> for bilinear B-splines is fixed to be</p><p class="math-container">\[\begin{aligned}
  \begin{pmatrix}
    -1 &amp; 1\\
    1 &amp; 0
  \end{pmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 2 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_cache_2D.jl#L31-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.CubicBSpline" href="#TrixiBottomTopography.CubicBSpline"><code>TrixiBottomTopography.CubicBSpline</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubicBSpline(x, Delta, Q, IP)</code></pre><p>One dimensional cubic B-spline structure that contains all important attributes to define a B-Spline interpolation function. Similar to <a href="#TrixiBottomTopography.LinearBSpline"><code>LinearBSpline</code></a> These attributes are:</p><ul><li><code>x</code>: Vector of values in x-direction</li><li><code>Delta</code>: Length of a single patch in the given data set. A patch is the area between two          consecutive <code>x</code> values. The value <code>Delta</code> corresponds to the distance between two          consecutive values in x-direction. As we are only considering Cartesian grids, <code>Delta</code>          is equal for all patches</li><li><code>Q</code>: Vector which contains the Control points</li><li><code>IP</code>: Coefficients matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_cache_1D.jl#L122-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.CubicBSpline-Tuple{String}" href="#TrixiBottomTopography.CubicBSpline-Tuple{String}"><code>TrixiBottomTopography.CubicBSpline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubicBSpline(path::String; end_condition = &quot;free&quot;, smoothing_factor = 0.0)</code></pre><p>A function that reads in the <code>x</code> and <code>y</code> values for <a href="#TrixiBottomTopography.CubicBSpline"><code>CubicBSpline</code></a> from a .txt file. The input values are:</p><ul><li><code>path</code>: String of a path of the specific .txt file</li><li><code>end_condition</code>: String which can either be <code>free</code> or <code>not-a-knot</code> and defines which                  end condition should be considered.                  By default this is set to <code>free</code></li><li><code>smoothing_factor</code>: Float64 <span>$\geq$</span> 0.0 which specifies the degree of smoothing of the <code>y</code> values.                     By default this value is set to <code>0.0</code> which corresponds to no smoothing.</li></ul><p>The .txt file has to have the following structure to be interpreted by this function:</p><ul><li>First line: comment <code># Number of x values</code></li><li>Second line: integer which gives the number of <code>x</code> values</li><li>Third line: comment <code># x values</code></li><li>Following lines: the <code>x</code> values where each value has its own line</li><li>Line after the x-values: comment <code># y values</code></li><li>Remaining lines: <code>y</code> values where each value has its own line</li></ul><p>Note that the number of <code>x</code> and <code>y</code> values have to be the same. An example can be found <a href="https://gist.githubusercontent.com/maxbertrand1996/b05a90e66025ee1ebddf444a32c3fa01/raw/90d375c1ac11b26589aab1fe92bd0e6f6daf37b7/Rhine_data_1D_10.txt">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_cache_1D.jl#L306-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.CubicBSpline-Tuple{Vector, Vector}" href="#TrixiBottomTopography.CubicBSpline-Tuple{Vector, Vector}"><code>TrixiBottomTopography.CubicBSpline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubicBSpline(x::Vector, y::Vector; end_condition = &quot;free&quot;, smoothing_factor = 0.0)</code></pre><p>This function calculates the inputs for the structure <a href="#TrixiBottomTopography.CubicBSpline"><code>CubicBSpline</code></a>. The input values are:</p><ul><li><code>x</code>: Vector that contains equally spaces values in x-direction</li><li><code>y</code>: Vector that contains values in y-direction</li><li><code>end_condition</code>: String that can either be <code>free</code> or <code>not-a-knot</code> and defines which                  end condition should be considered. By default this is set to &quot;free&quot;.</li><li><code>smoothing_factor</code>: Float64 <span>$\geq$</span> 0.0 which specifies the degree of smoothing of the <code>y</code>                     values. By default this value is set to <code>0.0</code> that corresponds to no                     smoothing.</li></ul><p>First the data is sorted via <a href="#TrixiBottomTopography.sort_data-Tuple{Vector, Vector, Matrix}"><code>sort_data</code></a> to guarantee that the <code>x</code> values are in ascending order.</p><p>The patch size <code>Delta</code> is calculated by subtracting the second and first <code>x</code> value. This can be done because we only consider equally spaced <code>x</code> values. (A patch is the area between two consecutive <code>x</code> values)</p><p>If a <code>smoothing_factor</code> &gt; 0.0 is set, the function <a href="#TrixiBottomTopography.spline_smoothing-Tuple{Number, Number, Vector}"><code>spline_smoothing</code></a> calculates new <code>y</code> values which guarantee a B-Spline with less curvature.</p><p>The coefficients matrix <code>IP</code> for linear B-splines is fixed to be</p><p class="math-container">\[\begin{aligned}
  IP = \begin{pmatrix}
    -1 &amp; 3 &amp; -3 &amp; 1\\
    3 &amp; -6 &amp; 3 &amp; 0\\
    -3 &amp; 0 &amp; 3 &amp; 0\\
    1 &amp; 4 &amp; 1 &amp; 0
  \end{pmatrix}
\end{aligned}\]</p><p>The &quot;free&quot; end condition requires the second and the second to last control points lie between the first and the third control point and that the second to last control points are between the third to last and the last control point. This procedure is only possible with at least two values in <code>x</code> data. The system of linear equations to determine the control points have the following form:</p><p class="math-container">\[\begin{aligned}
    \underbrace{\begin{bmatrix}
            0 \\ P_1 \\ P_2 \\ \vdots \\ P_{n-1} \\ P_n\\ 0
        \end{bmatrix}}_{:= P^*_{\text{free}}}
        = \frac{1}{6}
    \underbrace{
        \begin{bmatrix}
            1 &amp; -2 &amp; 1 &amp; 0 &amp; ... &amp; ... &amp; 0 \\
            1      &amp; 4 &amp; 1 &amp; 0 &amp; ... &amp; ... &amp; 0\\
            0      &amp; 1 &amp; 4 &amp; 1 &amp; 0   &amp;     &amp;     \vdots\\
            \vdots &amp;  0      &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0 &amp; \vdots\\
            \vdots &amp;       &amp; 0 &amp; 1 &amp; 4 &amp; 1 &amp; 0\\
            0 &amp; ... &amp; ... &amp; 0 &amp; 1 &amp; 4 &amp; 1\\
            0 &amp; ... &amp; ... &amp; 0 &amp; 1 &amp; -2 &amp; 1
        \end{bmatrix}
    }_{:= \Phi^*_{\text{free}}}
    \underbrace{\begin{bmatrix}
        Q_1 \\ Q_2 \\ Q_3 \\ \vdots \\ Q_n \\ Q_{n+1} \\ Q_{n+2}
    \end{bmatrix}}_{:= Q_{\text{free}}},
\end{aligned}\]</p><p>which is solved for <span>$Q_{\text{free}}$</span>.</p><p>The &quot;not-a-knot&quot; end condition requires the continuity of the third derivative in the second and second to last fit knot. This end condition is only possible with at least four values in <code>x</code> data. The system of linear equations to determine the control points has the following form:</p><p class="math-container">\[\begin{aligned}
    \underbrace{\begin{bmatrix}
        0 \\ P_1 \\ P_2 \\ \vdots \\ P_{n-1} \\ P_n\\ 0
    \end{bmatrix}}_{:= P^*_{\text{not-a-knot}}}
    = \frac{1}{6}
    \underbrace{
        \begin{bmatrix}
            -1 &amp; 4 &amp; -6 &amp; 4 &amp; -1 &amp; 0 &amp;... &amp;  0 \\
            1      &amp; 4 &amp; 1 &amp; 0 &amp; ... &amp; ... &amp; ... &amp; 0\\
            0      &amp; 1 &amp; 4 &amp; 1 &amp; 0   &amp;     &amp;     &amp;\vdots\\
            \vdots &amp;  0      &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0 &amp; &amp;\vdots\\
            \vdots &amp;  &amp; 0      &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0 &amp;\vdots\\
            \vdots &amp;    &amp;   &amp; 0 &amp; 1 &amp; 4 &amp; 1 &amp; 0\\
            0 &amp; ... &amp; ...  &amp; ... &amp; 0 &amp; 1 &amp; 4 &amp; 1\\
            0 &amp; ... &amp; 0 &amp; -1 &amp; 4 &amp; -6 &amp; 4 &amp; -1
        \end{bmatrix}
    }_{:= \Phi^*_{\text{not-a-knot}}}
    \underbrace{\begin{bmatrix}
        Q_1 \\ Q_2 \\ Q_3 \\ \vdots \\ \vdots \\ Q_n \\ Q_{n+1} \\ Q_{n+2}
    \end{bmatrix}}_{:= Q_{\text{not-a-knot}}}.
\end{aligned}\]</p><p>which is solved for <span>$Q_{\text{not-a-knot}}$</span>.</p><p>For both cases <span>$P_1,...,P_n = y_1,...,y_n$</span>.</p><p>A reference for the calculations in this script can be found in Chapter 1 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.  <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_cache_1D.jl#L144-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.LinearBSpline" href="#TrixiBottomTopography.LinearBSpline"><code>TrixiBottomTopography.LinearBSpline</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearBSpline(x, Delta, Q, IP)</code></pre><p>One dimensional linear B-spline structure which contains all important attributes to define a B-Spline interpolation function. These attributes are:</p><ul><li><code>x</code>: Vector of values in x-direction</li><li><code>Delta</code>: Length of a single patch in the given data set. A patch is the area between two          consecutive <code>x</code> values. The value <code>Delta</code> corresponds to the distance between two          consecutive values in x-direction. As we are only considering Cartesian grids,          <code>Delta</code> is equal for all patches</li><li><code>Q</code>: Vector which contains the control points</li><li><code>IP</code>: Coefficients matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_cache_1D.jl#L7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.LinearBSpline-Tuple{String}" href="#TrixiBottomTopography.LinearBSpline-Tuple{String}"><code>TrixiBottomTopography.LinearBSpline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearBSpline(path::String)</code></pre><p>A function that reads in the <code>x</code> and <code>y</code> values for <a href="#TrixiBottomTopography.LinearBSpline"><code>LinearBSpline</code></a> from a .txt file. The input values are:</p><ul><li><code>path</code>: String of a path of the specific .txt file</li></ul><p>The .txt file has to have the following structure to be interpreted by this function:</p><ul><li>First line: comment <code># Number of x values</code></li><li>Second line: integer which gives the number of <code>x</code> values</li><li>Third line: comment <code># x values</code></li><li>Following lines: the <code>x</code> values where each value has its own line</li><li>Line after the x-values: comment <code># y values</code></li><li>Remaining lines: <code>y</code> values where each value has its own line</li></ul><p>Note that the number of <code>x</code> and <code>y</code> values have to be the same. An example can be found <a href="https://gist.githubusercontent.com/maxbertrand1996/b05a90e66025ee1ebddf444a32c3fa01/raw/90d375c1ac11b26589aab1fe92bd0e6f6daf37b7/Rhine_data_1D_10.txt">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_cache_1D.jl#L86-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.LinearBSpline-Tuple{Vector, Vector}" href="#TrixiBottomTopography.LinearBSpline-Tuple{Vector, Vector}"><code>TrixiBottomTopography.LinearBSpline</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearBSpline(x::Vector, y::Vector)</code></pre><p>This function calculates the inputs for the structure <a href="#TrixiBottomTopography.LinearBSpline"><code>LinearBSpline</code></a>. The input values are:</p><ul><li><code>x</code>: A vector that contains equally spaced values in x-direction</li><li><code>y</code>: A vector that contains values in y-direction</li></ul><p>Linear B-spline interpolation is only possible if the data set has at least two values in <code>x</code>.</p><p>First the data is sorted via <a href="#TrixiBottomTopography.sort_data-Tuple{Vector, Vector, Matrix}"><code>sort_data</code></a> to guarantee that the <code>x</code> values are in ascending order.</p><p>The patch size <code>Delta</code> is calculated by subtracting the second and first <code>x</code> values. This can be done because we only consider equally spaced <code>x</code> values. A patch is the area between two consecutive <code>x</code> values.</p><p>For linear B-spline interpolation, the control points <code>Q</code> correspond with the values in <code>y</code>.</p><p>The coefficients matrix <code>IP</code> for linear B-splines is fixed to be</p><p class="math-container">\[\begin{aligned}
  \begin{pmatrix}
    -1 &amp; 1\\
    1 &amp; 0
  \end{pmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 1 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.  <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_cache_1D.jl#L29-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.calc_tps-Tuple{Number, Vector, Vector, Matrix}" href="#TrixiBottomTopography.calc_tps-Tuple{Number, Vector, Vector, Matrix}"><code>TrixiBottomTopography.calc_tps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_tps(lambda::Number, x::Vector, y::Vector, z::Matrix)</code></pre><p>The inputs to this function are:</p><ul><li><code>lambda</code>: Smoothing factor which specifies the degree of the smoothing that should take place</li><li><code>x</code>: Vector of <code>x</code> values</li><li><code>y</code>: Vector of <code>x</code> values</li><li><code>z</code>: Matrix with the <code>z</code> values to be smoothed where the values of <code>z</code> correspond to the      indexing <code>(y,x)</code></li></ul><p>This function uses the thin plate spline approach to perform the smoothing. To do so, the following linear equations system has to be solved for <code>coeff</code>:</p><p class="math-container">\[\begin{aligned}
    \underbrace{
        \begin{bmatrix}
            K &amp; P \\
            P^T &amp; O
        \end{bmatrix}
    }_{:= L}
    \underbrace{
        \begin{bmatrix}
            w \\ a
        \end{bmatrix}}_{\text{:= coeff}
    }
        =
    \underbrace{
        \begin{bmatrix}
            z\\o
        \end{bmatrix}}_{\text{:= rhs}
    }
\end{aligned}\]</p><p>First, the inputs are restructured using the function <a href="#TrixiBottomTopography.restructure_data-Tuple{Vector, Vector, Matrix}"><code>restructure_data</code></a> and saved in the variables <code>x_hat</code>, <code>y_hat</code> and <code>z_hat</code>.</p><p>Then the matrix <code>L</code> can be filled by setting <code>K</code> = <a href="#TrixiBottomTopography.tps_base_func-Tuple{Number}"><code>tps_base_func</code></a><code>(||(x_hat[i], y_hat[i]) - (x_hat[j], y_hat[j])||)</code> where <code>|| ||</code> is the Euclidian norm, <code>P</code> = <code>[1 x y]</code> and <code>O</code> = <span>$3\times 3$</span> zeros matrix.</p><p>Afterwards the vector <code>rhs</code> is filled by setting <code>z</code> = <code>z_hat</code> and <code>o</code> = a vector with three zeros.</p><p>Now the system is solved to redeem the vector <code>coeff</code>. This vector is then used to calculate the smoothed values for <code>z</code> and save them in <code>H_f</code> by the following function:</p><p class="math-container">\[\begin{align*}
z\_smth[i] = &amp;a[1] + a[2]x\_hat[i] + a[3]y\_hat[i] \\
        + &amp;\sum_{j = 0}^p w[j] tps\_base\_func(\|(x\_hat[i], y\_hat[i]) - (x\_hat[j], y\_hat[j]) \|)
\end{align*}\]</p><p>here <code>p</code> is the number of entries in <code>z_hat</code>.</p><p>A reference to the calculations can be found in the lecture notes of</p><ul><li>Gianluca Donato and Serge Belongie (2001), Approximate Thin Plate Spline Mappings <a href="https://link.springer.com/content/pdf/10.1007/3-540-47977-5_2.pdf">DOI: 10.1007/3-540-47977-5_2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_utils_2D.jl#L98-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.convert_dgm_1d-Tuple{String, String}" href="#TrixiBottomTopography.convert_dgm_1d-Tuple{String, String}"><code>TrixiBottomTopography.convert_dgm_1d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_dgm_1d(path_read::String, path_write::String; excerpt = 1, direction = &quot;x&quot;, section = 1)</code></pre><p>Function to convert <a href="https://www.opengeodata.nrw.de/produkte/geobasis/hm/dgm1_xyz/dgm1_xyz/">DGM</a> data files into one dimensional readable files.</p><p>Inputs:</p><ul><li><code>path_read</code>: String of the path of the DGM data which should be converted</li><li><code>path_write</code>: String of the path where the new file should be saved.             (Needs to also include the name of the file)</li><li><code>excerpt</code>: Optional integer that specifies a stride through of the data that will be extracted. E.g.          if excerpt is set to 10, only every 10th <code>x</code> and <code>y</code> value are considered with their          corresponding <code>z</code> values. The default value is 1 which means that every value is taken.</li><li><code>direction</code>: Optional String that specifies if the one dimensional data should be read from the            <code>x</code> or <code>y</code> direction. By default this is set to the <code>x</code> direction.</li><li><code>section</code>: Optional integer which can be between 1 and 1000 and specifies which section of the          other dimension should be chosen. By default this values is set to 1 which means          that if direction is set to <code>x</code>, the corresponding <code>z</code> values are taken with respect to the          first <code>y</code> value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/auxiliary/convert.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.convert_dgm_2d-Tuple{String, String}" href="#TrixiBottomTopography.convert_dgm_2d-Tuple{String, String}"><code>TrixiBottomTopography.convert_dgm_2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_dgm_2d(path_read::String, path_write::String; excerpt = 1)</code></pre><p>Function to convert <a href="https://www.opengeodata.nrw.de/produkte/geobasis/hm/dgm1_xyz/dgm1_xyz/">DGM</a> data files into two dimensional readable files.</p><p>Inputs:</p><ul><li><code>path_read</code>: String of the path of the DGM data which should be converted</li><li><code>path_write</code>: String of the path where the new file should be saved.             (Needs to also include the name of the file)</li><li><code>excerpt</code>: Optional integer that specifies a stride through of the data that will be extracted. E.g.          if excerpt is set to 10, only every 10th <code>x</code> and <code>y</code> value are considered with their          corresponding <code>z</code> values. The default value is 1 which means that every value is taken.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/auxiliary/convert.jl#L117-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.default_example-Tuple{}" href="#TrixiBottomTopography.default_example-Tuple{}"><code>TrixiBottomTopography.default_example</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TrixiBottomTopography.default_example()</code></pre><p>Function which calls the example file &quot;rhine<em>data</em>bicubic-nak.jl&quot; to check if including the package has worked. The example script creates a bicubic B-spline with the &quot;not-a-knot&quot; boundary condition. If a <a href="https://github.com/JuliaPlots/Makie.jl/">Makie.jl</a> backend such as <a href="https://github.com/JuliaPlots/GLMakie.jl/">GLMakie.jl</a> is included a plot will be generated as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/auxiliary/default_example.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.restructure_data-Tuple{Vector, Vector, Matrix}" href="#TrixiBottomTopography.restructure_data-Tuple{Vector, Vector, Matrix}"><code>TrixiBottomTopography.restructure_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">  restructure_data(x::Vector, y::Vector, z::Matrix)</code></pre><p>This function restructures the input values</p><ul><li><code>x</code>: a vector with <code>n</code> values in x-direction</li><li><code>y</code>: a vector with <code>m</code> values in y-direction</li><li><code>z</code>: a  <code>m</code> <span>$\times$</span> <code>n</code> matrix with values in z-direction where the values of <code>z</code> correspond      to the indexing <code>(y,x)</code></li></ul><p>The output is of the following form:</p><p class="math-container">\[\begin{aligned}
    \begin{bmatrix}
        x_1 &amp; y_1 &amp; z_{1,1}\\
        x_2 &amp; y_1 &amp; z_{1,2}\\
        &amp; \vdots &amp; \\
        x_n &amp; y_1 &amp; z_{1,n}\\
        x_1 &amp; y_2 &amp; z_{2,1}\\
        &amp; \vdots &amp; \\
        x_n &amp; y_m &amp; z_{m,n}
    \end{bmatrix}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_utils_2D.jl#L60-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.sort_data-Tuple{Vector, Vector, Matrix}" href="#TrixiBottomTopography.sort_data-Tuple{Vector, Vector, Matrix}"><code>TrixiBottomTopography.sort_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_data(x::Vector, y::Vector, z::Matrix)</code></pre><p>This function sorts the inputs vectors <code>x</code> and <code>y</code> in a ascending order and also reorders the input matrix <code>z</code> accordingly.</p><p>Therefore, first the <code>x</code> values are sorted with the matrix <code>z</code> accordingly and afterwards the <code>y</code> values are sorted with the matrix <code>z</code> accordingly.</p><p>The sorted <code>x</code>, <code>y</code> and <code>z</code> values are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_utils_2D.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.sort_data-Tuple{Vector, Vector}" href="#TrixiBottomTopography.sort_data-Tuple{Vector, Vector}"><code>TrixiBottomTopography.sort_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_data(x::Vector,y::Vector)</code></pre><p>Sorts the input vectors <code>x</code> and <code>y</code> so that <code>x</code> is in ascending order and the <code>y</code> values accordingly to still correspond to the <code>x</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_utils_1D.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.spline_interpolation-Tuple{BicubicBSpline, Number, Number}" href="#TrixiBottomTopography.spline_interpolation-Tuple{BicubicBSpline, Number, Number}"><code>TrixiBottomTopography.spline_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spline_interpolation(b_spline::BicubicBSpline, x::Number, y::Number)</code></pre><p>The inputs are the <a href="#TrixiBottomTopography.BicubicBSpline"><code>BicubicBSpline</code></a> object and the variable <code>x</code> and <code>y</code> at which the spline will be evaluated.</p><p>The parameters <code>i</code> and <code>j</code> indicate the patch in which <code>(x,y)</code> is located. This information is also used to get the correct control points from <code>Q</code>. A patch is the area between two consecutive <code>b_spline.x</code> and <code>b_spline.y</code> values.</p><p><code>my</code> is  an interim variable which maps <code>x</code> to the interval <span>$[0,1]$</span> for further calculations. <code>ny</code> does the same for <code>y</code>.</p><p>To evaluate the spline at <code>(x,y)</code>, we have to calculate the following:</p><p class="math-container">\[\begin{aligned}
c_{i,j,3}(\mu_i(x),\nu_j(y)) = \frac{1}{36}
    \begin{bmatrix} \nu_j^3(y) \\ \nu_j^2(y) \\ \nu_j(y) \\ 1 \end{bmatrix}^T
    \underbrace{\begin{bmatrix}
        -1 &amp; 3 &amp; -3 &amp; 1\\
        3 &amp; -6 &amp; 3 &amp; 0\\
        -3 &amp; 0 &amp; 3 &amp; 0\\
        1 &amp; 4 &amp; 1 &amp; 0
    \end{bmatrix}}_{\text{IP}}
    \begin{bmatrix}
        Q_{i,j} &amp; Q_{i+1,j} &amp; Q_{i+2,j} &amp; Q_{i+3,j}\\
        Q_{i,j+1} &amp; Q_{i+1,j+1} &amp; Q_{i+2,j+1} &amp; Q_{i+3,j+1}\\
        Q_{i,j+2} &amp; Q_{i+1,j+2} &amp; Q_{i+2,j+2} &amp; Q_{i+3,j+2}\\
        Q_{i,j+3} &amp; Q_{i+1,j+3} &amp; Q_{i+2,j+3} &amp; Q_{i+3,j+3}
    \end{bmatrix}
    \underbrace{\begin{bmatrix}
        -1 &amp; 3 &amp; -3 &amp; 1\\
        3 &amp; -6 &amp; 0 &amp; 4\\
        -3 &amp; 3 &amp; 3 &amp; 1\\
        1 &amp; 0 &amp; 0 &amp; 0
    \end{bmatrix}}_{\text{IP}}
    \begin{bmatrix} \mu_i^3(x) \\ \mu_i^2(x) \\ \mu_i(x) \\ 1 \end{bmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 2 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020),  Cubic and bicubic spline interpolation in Python.  <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_methods_2D.jl#L67-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.spline_interpolation-Tuple{BilinearBSpline, Number, Number}" href="#TrixiBottomTopography.spline_interpolation-Tuple{BilinearBSpline, Number, Number}"><code>TrixiBottomTopography.spline_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spline_interpolation(b_spline::BilinearBSpline, x::Number, y::Number)</code></pre><p>The inputs are the <a href="#TrixiBottomTopography.BilinearBSpline"><code>BilinearBSpline</code></a> object and the variable <code>x</code> and <code>y</code> at which the spline will be evaluated.</p><p>The parameters <code>i</code> and <code>j</code> indicate the patch in which <code>(x,y)</code> is located. This information is also used to get the correct control points from <code>Q</code>. A patch is the area between two consecutive <code>b_spline.x</code> and <code>b_spline.y</code> values.</p><p><code>my</code> is  an interim variable that maps <code>x</code> to the interval <span>$[0,1]$</span> for further calculations. <code>ny</code> does the same for <code>y</code>.</p><p>To evaluate the spline at <code>(x,y)</code>, we have to calculate the following:</p><p class="math-container">\[\begin{aligned}
c_{i,j,1}(\mu_i(x),\nu_j(y)) =
    \begin{bmatrix} \nu_j(y)\\ 1 \end{bmatrix}^T
    \underbrace{\begin{bmatrix} -1 &amp; 1\\ 1 &amp; 0 \end{bmatrix}}_{\text{IP}}
    \begin{bmatrix} Q_{i,j} &amp; Q_{i,j+1}\\ Q_{i+1,j} &amp; Q_{i+1,j+1} \end{bmatrix}
    \underbrace{\begin{bmatrix} -1 &amp; 1\\ 1 &amp; 0 \end{bmatrix}}_{\text{IP}^T}
    \begin{bmatrix} \mu_i(x) \\ 1\end{bmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 2 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020) Cubic and bicubic spline interpolation in Python. <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_methods_2D.jl#L7-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.spline_interpolation-Tuple{CubicBSpline, Number}" href="#TrixiBottomTopography.spline_interpolation-Tuple{CubicBSpline, Number}"><code>TrixiBottomTopography.spline_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spline_interpolation(b_spline::CubicBSpline, x::Number)</code></pre><p>The inputs are the <a href="#TrixiBottomTopography.CubicBSpline"><code>CubicBSpline</code></a> object and a variable <code>x</code> at which the spline will be evaluated.</p><p>The parameter <code>i</code> indicates the patch in which the variable <code>x</code> is located. This parameter is also used to get the correct control points from <code>Q</code>. A patch is the area between two consecutive <code>b_spline.x</code> values.</p><p><code>kappa</code> is  an interim variable which maps <code>t</code> to the interval <span>$[0,1]$</span> for further calculations.</p><p>To evaluate the spline at <code>x</code>, we have to calculate the following:</p><p class="math-container">\[\begin{aligned}
c_{i,3}\left(\kappa_i(x) \right) = \frac{1}{6}
    \begin{bmatrix}
        \kappa_i(x)^3\\ \kappa_i(x)^2\\ \kappa_i(x) \\1
    \end{bmatrix}^T
    \underbrace{\begin{bmatrix}
        -1 &amp; 3 &amp; -3 &amp; 1\\
        3 &amp; -6 &amp; 3 &amp; 0\\
        -3 &amp; 0 &amp; 3 &amp; 0\\
        1 &amp; 4 &amp; 1 &amp; 0
    \end{bmatrix}}_{\text{IP}}
    \begin{bmatrix}
        Q_{i,\text{free}}\\ Q_{i+1,\text{free}}\\ Q_{i+2,\text{free}}\\ Q_{i+3,\text{free}}
    \end{bmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 1 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_methods_1D.jl#L65-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.spline_interpolation-Tuple{LinearBSpline, Number}" href="#TrixiBottomTopography.spline_interpolation-Tuple{LinearBSpline, Number}"><code>TrixiBottomTopography.spline_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spline_interpolation(b_spline::LinearBSpline, x::Number)</code></pre><p>The inputs are the <a href="#TrixiBottomTopography.LinearBSpline"><code>LinearBSpline</code></a> object and a variable <code>x</code> at which the spline will be evaluated.</p><p>The parameter <code>i</code> indicates the patch in which the variable <code>x</code> is located. This parameter is also used to get the correct control points from <code>Q</code>. A patch is the area between two consecutive <code>b_spline.x</code> values.</p><p><code>kappa</code> is an interim variable which maps <code>x</code> to the interval <span>$[0,1]$</span> for further calculations.</p><p>To evaluate the spline at <code>x</code>, we have to calculate the following:</p><p class="math-container">\[\begin{aligned}
c_{i,1}(\kappa_i(x)) =
    \begin{bmatrix}
        \kappa_i(x)\\ 1
    \end{bmatrix}^T
    \begin{bmatrix}
        -1 &amp; 1\\1 &amp; 0
    \end{bmatrix}
    \begin{bmatrix}
        Q_i\\Q_{i+1}
    \end{bmatrix}
\end{aligned}\]</p><p>A reference for the calculations in this script can be found in Chapter 1 of</p><ul><li>Quentin Agrapart &amp; Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. <a href="https://hal.archives-ouvertes.fr/hal-03017566v2">hal-03017566v2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_methods_1D.jl#L7-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.spline_smoothing-Tuple{Number, Number, Vector}" href="#TrixiBottomTopography.spline_smoothing-Tuple{Number, Number, Vector}"><code>TrixiBottomTopography.spline_smoothing</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spline_smoothing(lambda::Number, Delta::Number, y::Vector)</code></pre><p>The inputs to this function are:</p><ul><li><code>lambda</code>: Smoothing factor which specifies the degree of the smoothing that should take place</li><li><code>Delta</code>: Step size of a patch (A patch is the area between two consecutive <code>x</code> values)</li><li><code>y</code>: Data values to be smoothed</li></ul><p>The goal is to find a new interpolation values <span>$\hat{y}$</span> for <span>$y$</span>, so that for given <span>$\lambda$</span>, the following equation is minimized:</p><p class="math-container">\[\begin{aligned}
    \text{PSS} = \sum_{i = 1}^{n} \left( y_i - \underbrace{S(t_i)}_{=\hat{y}_i} \right)^2
    + \lambda \int_{x_1}^{x_n} (S&#39;&#39;(t))^2 dt,
\end{aligned}\]</p><p>where <span>$S(t)$</span> is a cubic spline function. <span>$\hat{y}$</span> is determined as follows:</p><p class="math-container">\[\begin{aligned}
    \hat{y} = (I+\lambda K)^{-1} y
\end{aligned}\]</p><p>where <span>$I$</span> is the <span>$n \times n$</span> identity matrix and <span>$K = \Delta_2^T W^{-1} \Delta_2$</span> with</p><p class="math-container">\[\begin{aligned}
    \Delta_2 = \begin{pmatrix}
        1/\Delta &amp; -2/\Delta &amp; 1/\Delta &amp; ... &amp; 0\\
        0 &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0\\
        0 &amp; ... &amp; 1/\Delta &amp; -2/\Delta &amp; 1/\Delta
    \end{pmatrix} \in \mathbb{R}^{(n-2) \times n}
\end{aligned}\]</p><p>and</p><p class="math-container">\[\begin{aligned}
    W = \begin{pmatrix}
        2/3 \Delta &amp; 1/6 \Delta &amp; 0 &amp; ... &amp; 0\\
        1/6 \Delta &amp; 2/3 \Delta &amp; 1/6 \Delta &amp; ... &amp; 0\\
        0 &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0\\
        0 &amp; ... &amp; 0 &amp; 2/3 \Delta &amp; 1/6 \Delta
    \end{pmatrix} \in \mathbb{R}^{n \times n}
\end{aligned}\]</p><ul><li>Germán Rodríguez (2001), <a href="https://data.princeton.edu/eco572/smoothing.pdf">Smoothing and non-parametric regression</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/1D/spline_utils_1D.jl#L24-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiBottomTopography.tps_base_func-Tuple{Number}" href="#TrixiBottomTopography.tps_base_func-Tuple{Number}"><code>TrixiBottomTopography.tps_base_func</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tps_base_func(r::Number)</code></pre><p>Thin plate spline basis function.</p><ul><li>Gianluca Donato and Serge Belongie (2001) Approximate Thin Plate Spline Mappings <a href="https://link.springer.com/content/pdf/10.1007/3-540-47977-5_2.pdf">DOI: 10.1007/3-540-47977-5_2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/8c09a813d84c8b1adfdfd210c2efc6a251f2d92e/src/2D/spline_utils_2D.jl#L42-L50">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../license/">« License</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 20 May 2025 14:10">Tuesday 20 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
