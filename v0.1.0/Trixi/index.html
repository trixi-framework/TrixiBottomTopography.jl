<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Trixi.jl examples · TrixiBottomTopography.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://trixi-framework.github.io/TrixiBottomTopography.jl/dev/Trixi/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TrixiBottomTopography.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Overview</span><ul><li><a class="tocitem" href="../conversion/">Data conversion</a></li><li><a class="tocitem" href="../structure/">B-spline structure</a></li><li><a class="tocitem" href="../function/">B-spline function</a></li></ul></li><li class="is-active"><a class="tocitem" href>Trixi.jl examples</a><ul class="internal"><li><a class="tocitem" href="#Two-dimensional-dam-break"><span>Two dimensional dam break</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../licence/">Licence</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Trixi.jl examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Trixi.jl examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/main/docs/src/Trixi.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples-with-Trixi.jl"><a class="docs-heading-anchor" href="#Examples-with-Trixi.jl">Examples with Trixi.jl</a><a id="Examples-with-Trixi.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-with-Trixi.jl" title="Permalink"></a></h1><p>As mentioned in the <a href="https://trixi-framework.github.io/TrixiBottomTopography.jl/dev/">Home</a> section of this documentation, <code>TrixiBottomTopography.jl</code> was initially developed as a supplementary package for the numerical solver <a href="https://github.com/trixi-framework/Trixi.jl">Trixi.jl</a> to enable the user to use real world geographical data for the bottom topography function of the shallow water equations.</p><p>In this section, a one dimensional example is presented which uses the functionalities of <code>TrixiBottomTopography.jl</code> with <a href="https://github.com/trixi-framework/Trixi.jl">Trixi.jl</a> to simulate a dam break problem.</p><p>The underlying example file can be found <a href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/main/examples/trixi_dam_break_1D.jl">here</a>.</p><p>First, all the necessary packages must be included at the beginning of the file.</p><pre><code class="language-julia hljs"># Include packages
using TrixiBottomTopography
using Plots
using OrdinaryDiffEq
using Trixi</code></pre><ul><li><code>Plots</code> is responsible for visualizing the approximate solution of the dam break problem.</li><li><code>OrdinaryDiffEq</code> always has to be added when working with <code>Trixi</code>.</li></ul><p>Next, the underlying bottom topography data is downloaded from a gist.</p><pre><code class="language-julia hljs"># Download one dimensional Rhine bottom data from gist
Rhine_data = download(&quot;https://gist.githubusercontent.com/maxbertrand1996/19c33682b99bfb1cc3116f31dd49bdb9/raw/d96499a1ffe250bc8e4cca8622779bae61543fd8/Rhine_data_1D_40_x_841.txt&quot;)</code></pre><p>The downloaded data is then used to define the B-spline interpolation function as described in <a href="https://trixi-framework.github.io/TrixiBottomTopography.jl/dev/structure/">B-spline structure</a> and <a href="https://trixi-framework.github.io/TrixiBottomTopography.jl/dev/function/">B-spline function</a>. In this case, a cubic B-spline interpolation function with free end condition is chosen.</p><pre><code class="language-julia hljs"># B-spline interpolation of the underlying data
spline_struct = CubicBSpline(Rhine_data)
spline_func(x) = spline_interpolation(spline_struct, x)</code></pre><p>Now that the B-spline interpolation function is determined, the one dimensional shallow water equations implemented in <code>Trixi.jl</code> can be defined by calling:</p><pre><code class="language-julia hljs"># Defining one dimensional shallow water equations
equations = ShallowWaterEquations1D(gravity_constant=1.0, H0=55.0)</code></pre><p>Here the gravity constant has been chosen to be <span>$1.0$</span>, and the background total water height <span>$H_0$</span> has been set to <span>$55.0$</span>.</p><p>Next, the initial condition for the dam break problem can be defined. At time <span>$t=0$</span>, a part of the water height in the center of the domain with a diameter of <span>$100$</span> is set to <span>$60.0$</span> while the rest of the domain stays at the background water height <span>$55.0$</span>. Additionally, we can see that the bottom topography <code>b</code> is defined by the B-spline interpolation function <code>spline_func</code> and is set in the initial condition.</p><pre><code class="language-julia hljs"># Defining initial condition for the dam break problem
function initial_condition_dam_break(x, t, equations::ShallowWaterEquations1D)

  inicenter = SVector(357490.0)
  x_norm = x[1] - inicenter[1]
  r = abs(x_norm)

  # Calculate primitive variables
  H =  r &lt; 50 ? 60.0 : 55.0
  v = 0.0
  b = spline_func(x[1])

  return prim2cons(SVector(H, v, b), equations)
end</code></pre><p>After the initial condition, we can set the boundary conditions. In this case, a reflective wall condition is chosen, which is already implemented in <code>Trixi.jl</code> for the one dimensional shallow water equations.</p><pre><code class="language-julia hljs"># Setting initaial condition
initial_condition = initial_condition_dam_break

# Setting the boundary to be a reflective wall
boundary_condition = boundary_condition_slip_wall</code></pre><p>The upcoming code parts will <strong>not</strong> be covered in full detail. To get a more profound understanding of the routines, please see the <a href="https://trixi-framework.github.io/Trixi.jl/stable/">Trixi.jl documentation</a>.</p><p>The following code snippet sets up the discontinuous Galerkin spectral element method (DGSEM). In this solver type, we can specify which flux functions for the surface and volume fluxes will be taken, as well as the polynomial degree (<code>polydeg</code>) of the polynomials used in the approximation space.</p><pre><code class="language-julia hljs">###############################################################################
# Get the DG approximation space

volume_flux = (flux_wintermeyer_etal, flux_nonconservative_wintermeyer_etal)
solver = DGSEM(polydeg=3, surface_flux=(flux_hll, flux_nonconservative_fjordholm_etal),
               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))</code></pre><p>After the solver comes the specification of the mesh in the approximation. In this case, a <a href="https://trixi-framework.github.io/Trixi.jl/stable/meshes/tree_mesh/"><code>TreeMesh</code></a> is chosen, which is a Cartesian mesh. Here the domain borders must be defined, as well as the number of initial elements (<span>$2$</span> to the power of <code>initial_refinement_level</code>). Also, we have to indicate if the domain is periodic. In this example, boundary conditions were defined. Thus the periodicity is set to <code>false</code>.</p><p>Once the underlying mesh is constructed, a semidiscretization object can be created by calling <code>SemiDiscretizationHyperbolic</code>. This collects all the building blocks needed to set up the semidiscretization:</p><ul><li>The underlying mesh.</li><li>The set of equations.</li><li>The initial condition.</li><li>The solver (in this case DGSEM).</li><li>The boundary conditions.</li></ul><pre><code class="language-julia hljs">###############################################################################
# Get the TreeMesh and setup a periodic mesh

coordinates_min = spline_struct.x[1]
coordinates_max = spline_struct.x[end]
mesh = TreeMesh(coordinates_min, coordinates_max,
                initial_refinement_level=3,
                n_cells_max=10_000,
                periodicity = false)

# create the semi discretization object
semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,
                                    boundary_conditions = boundary_condition)</code></pre><p>An ordinary differential equations object is set up using a specified time range, <code>tspan</code>, and the semidiscretization object, <code>semi</code>.</p><pre><code class="language-julia hljs">###############################################################################
# ODE solvers

tspan = (0.0, 100.0)
ode = semidiscretize(semi, tspan)</code></pre><p>The ordinary differential equations object <code>ode</code> is solved by the function <code>sol</code> which is part of the <code>OrdinaryDiffEq</code> package. Here the time stepping method can be specified (in this case, <code>RDPK3SpFSAL49()</code>) as well as some tolerances responsible for an error-based time step control.</p><pre><code class="language-julia hljs">###############################################################################
# run the simulation

# use a Runge-Kutta method with automatic (error-based) time step size control
sol = solve(ode, RDPK3SpFSAL49(), abstol=1.0e-8, reltol=1.0e-8,
            save_everystep=true);</code></pre><p>At this point, the calculations would generally be finished. However, to visualize the dam break problem, we want to create a .gif file of the solution. To do so, we have set the <code>save_everystep</code> attribute to <code>true</code>. This means that the solution for every time step will be callable afterwards.</p><p>First of all, a plotting backend is chosen. Here we use <code>pyplot()</code> as the resulting plots look very clear. Then we define an <code>animation</code> loop using the macro <code>@animate</code> over every second of the interim solutions. Inside the loop, the <code>PlotData2D</code> functionality from <code>Trixi.jl</code> is called to create a plotting object. Afterwards, this plotting object can be plotted using the known <code>plot</code> command.</p><p>The <code>gif</code> function uses <code>animation</code> to create a .gif from the plots for every second-time step and saves it in the specified location. Additionally, the frames per second rate can be set in the <code>fps</code> attribute.</p><pre><code class="language-julia hljs"># Create .gif animation of the solution
pyplot()
animation = @animate for k= 1:2:length(sol.t)
  pd = PlotData1D(sol.u[k], semi)
  plot(pd[&quot;H&quot;])
  plot!(pd[&quot;b&quot;], ylim=(38,65), title=&quot;t=$(sol.t[k])&quot;, xlabel=&quot;ETRS89 East&quot;, ylabel=&quot;DHHN2016&quot;)
end

gif(animation, &quot;examples\\plots\\dam_break_1d.gif&quot;, fps=15)</code></pre><p>This is the resulting .gif animation.</p><p><img src="https://user-images.githubusercontent.com/101979498/203507054-2faca609-2628-4fea-9a4c-5788d02a237b.gif" alt="gif"/></p><h2 id="Two-dimensional-dam-break"><a class="docs-heading-anchor" href="#Two-dimensional-dam-break">Two dimensional dam break</a><a id="Two-dimensional-dam-break-1"></a><a class="docs-heading-anchor-permalink" href="#Two-dimensional-dam-break" title="Permalink"></a></h2><p>The underlying example file can be found <a href="https://github.com/trixi-framework/TrixiBottomTopography.jl/blob/main/examples/trixi_dam_break_2D.jl">here</a>.</p><p>The two dimensional example is very similar to the one dimensional case.</p><p>First, all the necessary packages and the underlying bottom topography data are loaded.</p><pre><code class="language-julia hljs"># Include packages
using TrixiBottomTopography
using Plots
using LinearAlgebra
using OrdinaryDiffEq
using Trixi

Rhine_data = download(&quot;https://gist.githubusercontent.com/maxbertrand1996/a30db4dc9f5427c78160321d75a08166/raw/fa53ceb39ac82a6966cbb14e1220656cf7f97c1b/Rhine_data_2D_40.txt&quot;)</code></pre><p>Using the data, a bicubic B-spline interpolation is performed on the data to define a bottom topography function.</p><pre><code class="language-julia hljs"># B-spline interpolation of the underlying data
spline_struct = BicubicBSpline(Rhine_data)
spline_func(x,y) = spline_interpolation(spline_struct, x, y)</code></pre><p>Then the two dimensional shallow water equations are defined, where the gravitational constant has been chosen to be <code>3.0</code> and the initial water height <code>55.0</code>. Afterwards, the initial condition is defined. Similar to the one dimensional case, in the center of the domain, a circular part with a diameter of <code>100.0</code> is chosen where the initial water height is chosen to be <code>10.0</code> units higher.</p><pre><code class="language-julia hljs">equations = ShallowWaterEquations2D(gravity_constant=3.0, H0=55.0)

function initial_condition_wave(x, t, equations::ShallowWaterEquations2D)

  inicenter = SVector(357490.0, 5646519.0)
  x_norm = x - inicenter
  r = norm(x_norm)

  # Calculate primitive variables
  H =  r &lt; 50 ? 65.0 : 55.0
  v1 = 0.0
  v2 = 0.0

  x1, x2 = x
  b = spline_func(x1, x2)

  return prim2cons(SVector(H, v1, v2, b), equations)
end

initial_condition = initial_condition_wave</code></pre><p>As we can see, there is no boundary condition specified. This is because, at this stage, <code>boundary_condition_slip_wall</code> has not been implemented into <code>Trixi.jl</code> for the two dimensional shallow water equations.</p><p>The DGSEM solver is set up as in the one dimensional case.</p><pre><code class="language-julia hljs">###############################################################################
# Get the DG approximation space

volume_flux = (flux_wintermeyer_etal, flux_nonconservative_wintermeyer_etal)
solver = DGSEM(polydeg=3, surface_flux=(flux_fjordholm_etal, flux_nonconservative_fjordholm_etal),
               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))</code></pre><p>Now the mesh has to be specified. Because we do not have any boundary conditions defined, we can only assume to have a periodic domain. Therefore <code>periodicity</code> does not have to be specified as it is set to <code>true</code> by default.</p><pre><code class="language-julia hljs">###############################################################################
# Get the TreeMesh and setup a periodic mesh

coordinates_min = (spline_struct.x[1], spline_struct.y[1])
coordinates_max = (spline_struct.x[end], spline_struct.y[end])
mesh = TreeMesh(coordinates_min, coordinates_max,
                initial_refinement_level=3,
                n_cells_max=10_000)</code></pre><p>When calling the semidiscretization object again, <code>boundary_conditions</code> does not have to be specified.</p><pre><code class="language-julia hljs"># create the semi discretization object
semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver)</code></pre><p>The solution of the PDE and the.gif animation is analogous to the one dimensional case except that we chose <code>PlotData2D</code> to create the plotting object instead of <code>PlotData1D</code> as we are in the two dimensional case now.</p><pre><code class="language-julia hljs">###############################################################################
# ODE solvers, callbacks etc.

tspan = (0.0, 100.0)
ode = semidiscretize(semi, tspan)

###############################################################################
# run the simulation

# use a Runge-Kutta method with automatic (error based) time step size control
sol = solve(ode, RDPK3SpFSAL49(), abstol=1.0e-8, reltol=1.0e-8, save_everystep=true);

# Create .gif animation of the solution
pyplot()
animation = @animate for k= 1:6:length(sol.t)
  pd = PlotData2D(sol.u[k], semi)
  wireframe(pd[&quot;H&quot;])
  surface!(pd[&quot;b&quot;], zlim=(38,65), camera = (30,20), title=&quot;t=$(sol.t[k])&quot;,
            xlabel=&quot;E&quot;, ylabel=&quot;N&quot;, zlabel=&quot;H&quot;)
end

gif(animation, &quot;examples\\plots\\dam_break_2d.gif&quot;, fps=15)</code></pre><p>This is the resulting .gif animation.</p><p><img src="https://user-images.githubusercontent.com/101979498/203507057-f4fa5ef2-e852-493d-8df6-497c1e2a9a51.gif" alt="gif"/></p><p>For the bottom topography, the domain&#39;s boundaries look weird. The reason for that is a bug in <code>PlotData2D</code> of <code>Trixi.jl</code>. Once this has been addressed, the plotted bottom topography will look similar to the one in <a href="https://trixi-framework.github.io/TrixiBottomTopography.jl/dev/function/#Two-dimensional-case">the previous section</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../function/">« B-spline function</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 1 April 2025 20:01">Tuesday 1 April 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
